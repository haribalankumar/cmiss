      SUBROUTINE MAGSOLOPTI(DIPOLE_CEN_NTIME,DIPOLE_DIR_NTIME,IBT,IDO,
     '  INP,NBH,NBJ,NDET,NDIPOLES,NEELEM,NENP,NGAP,NKH,NKHE,NKJE,
     '  NP_INTERFACE,NLL,NPNE,nr,NRLISTL,NVHE,NVJE,NW,nx,CE,CURVCORRECT,
     '  DETLOC,DET_ADAPT,DIPOLE_CEN,DIPOLE_DIR,DL,H_FIELD,LOC_TIME,PG,
     '  PG_J,PG_Q,PG_U,RAD,RG,SE,WG,XE,XG1,XIG,XIG_J,XIG_Q,XIG_U,XN,XP,
     '  XPFP,XR,YD_LOCAL,ZE,ZP,MAGDIPOLE,MAGVOLUME,ERROR,*)

C#### Subroutine: MAGSOLOPTI
C###  Description:
C###    MAGSOLOPTI calculates the magnetic field
C###    that results from a potential field throughout a
C###    domain by putting the domain into a box and doing
C###    domain solutions at grid points. There are two magnetic
C###    sources, the first is the primary current source and the
C###    second is the field generated by conductivity changes across
C###    region boundaries.
C**** Created by Martin Buist - December 2001

      IMPLICIT NONE

      INCLUDE 'b00.cmn'
      INCLUDE 'b01.cmn'
      INCLUDE 'b10.cmn'
      INCLUDE 'bem000.cmn'
      INCLUDE 'cbdi02.cmn'
      INCLUDE 'coup00.cmn'
      INCLUDE 'geom00.cmn'
      INCLUDE 'jtyp00.cmn'
      INCLUDE 'ktyp90.cmn'
      INCLUDE 'loc00.inc'
      INCLUDE 'loc00.cmn'
      INCLUDE 'tol00.cmn'

!     Parameter List
      INTEGER DIPOLE_CEN_NTIME(NDIPOLEM,NRM),
     '  DIPOLE_DIR_NTIME(NDIPOLEM,NRM),IBT(3,NIM,NBFM),
     '  IDO(NKM,NNM,0:NIM,NBFM),INP(NNM,NIM,NBFM),NBH(NHM,NCM,NEM),
     '  NBJ(NJM,NEM),NDET(NBFM,0:NNM),NDIPOLES(NRM),
     '  NEELEM(0:NE_R_M,0:NRM),NENP(NPM,0:NEPM,0:NRM),NGAP(NIM,NBM),
     '  NKH(NHM,NPM,NCM,0:NRM),NKHE(NKM,NNM,NHM,NEM),
     '  NKJE(NKM,NNM,NJM,NEM),NP_INTERFACE(0:NPM,0:3),NLL(12,NEM),
     '  NPNE(NNM,NBFM,NEM),nr,NRLISTL(0:99),NVHE(NNM,NBFM,NHM,NEM),
     '  NVJE(NNM,NBFM,NJM,NEM),NW(NEM,3),nx
      REAL*8 CE(NMM,NEM),CURVCORRECT(2,2,NNM,NEM),
     '  DETLOC(NBFM,0:NNM,NGM,6),DET_ADAPT(NBFM,0:NNM,NGM),
     '  DIPOLE_CEN(4,0:NDIPTIMM,NDIPOLEM,NRM),
     '  DIPOLE_DIR(4,0:NDIPTIMM,NDIPOLEM,NRM),DL(3,NLM),H_FIELD(*),
     '  LOC_TIME,PG(NSM,NUM,NGM,NBM),PG_J(NSM,NUM,NGM),
     '  PG_Q(NSM,NUM,NGM),PG_U(NSM,NUM,NGM),RAD(NGM),RG(NGM),
     '  SE(NSM,NBFM,NEM),WG(NGM,NBM),XE(NSM,NJM),XG1(NJM,NUM,NGM),
     '  XIG(NIM,NGM,NBM),XIG_J(NIM,NGM),XIG_Q(NIM,NGM),XIG_U(NIM,NGM),
     '  XN(NJM,NGM),XP(NKM,NVM,NJM,NPM),XPFP(*),XR(NJM,NGM),
     '  YD_LOCAL(9,9),ZE(NSM,NHM),ZP(NKM,NVM,NHM,NPM,NCM)
      CHARACTER ERROR*(*)
      LOGICAL MAGDIPOLE,MAGVOLUME
!     Local Variables
      INTEGER intscheme,ISP,MK,nb,nb2,nbbem,nb1j,nb1jp,nbqh,nbuh,
     '  nbuhp,n_dipole,ne,ng,nh,nhx,nk,nk1,nn,nnmin,nnsp,noelem,
     '  np,npnn,ns,nsplit,nv
      REAL*8 CENTRE(3),D(2),DDOT,DGREEN_LOC,DGREENSTATIC,DIRECTION(3),
     '  DSIGMA,DXXI(3,3),MINDIST,SUM,SUMU1,SUMU2,SUMU3,SUMXG,XIMIN(2)
      LOGICAL USEADAPINT

      CALL ENTERS('MAGSOLOPTI',*9999)

      nhx=1
      nh=NH_LOC(nhx,nx)

C***  Initialise the magnetic field
      H_FIELD(1)=0.0d0
      H_FIELD(2)=0.0d0
      H_FIELD(3)=0.0d0

C      XPFP(1)=1.76776695296637d0*3.1d0/5.0d0
C      XPFP(2)=3.06186217847897d0*3.1d0/5.0d0
C      XPFP(3)=3.53553390593274d0*3.1d0/5.0d0


C!!! LKC Comitted 11-JAN-2011      
C!!!      
C!!! LKC 27-JAN-2009 I don't think the calculations for XN are correct
C!!! here. Refer to equivalent changes made in MAGSOL.f on the same date.
C!!! Probably more issues hidden around that need fixing.
C!!!      
      WRITE(OP_STRING,'(/'' >>WARNING: '',A)')
     &  'LKC - Code is likely to be buggy.'
      CALL WRITES(IOER,OP_STRING,ERROR,*9999)
      
C***  Find the unit outward normal to the field point.
      XN(1,1)=XPFP(1)/
     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)
      XN(2,1)=XPFP(2)/
     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)
      XN(3,1)=XPFP(3)/
     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)

C***  Calculate the magnetic field contribution from the
C     boundary element surfaces
      IF(MAGVOLUME) THEN
        YD_LOCAL(1,1)=0.0d0
        YD_LOCAL(1,2)=0.0d0
        YD_LOCAL(1,3)=0.0d0

C***    Loop over elements in the current region
        DO noelem=1,NEELEM(0,nr)
          ne=NEELEM(noelem,nr)
          np=NPNE(1,NBJ(1,ne),ne)
          IF((NP_INTERFACE(np,1).EQ.nr).OR.(NP_INTERFACE(np,0).EQ.1))
     '      THEN

C***        Calculate conductivity change
            IF(IGREN(nr).EQ.2) THEN
C***          Assumed by standard Laplace equation
              IF(NP_INTERFACE(np,0).EQ.1) THEN
                DSIGMA=1.0d0 ! -zero outside
              ELSE
                DSIGMA=0.0d0 ! standard Laplace = no change
              ENDIF
            ELSE
              IF(NP_INTERFACE(np,0).EQ.1) THEN
                DSIGMA=CE(1,ne) ! -zero outside
              ELSE
                DSIGMA=CE(1,ne)-CE(1,NENP(np,1,NP_INTERFACE(np,2)))
              ENDIF
            ENDIF

C***        If the conductivities are the same, there is no
C           magnetic field contribution
            IF(DABS(DSIGMA).LT.ZERO_TOL) THEN
              !do nothing
              IF(DOP) THEN
                WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                WRITE(OP_STRING,'(''   No conductivity change'')')
                CALL WRITES(IODI,OP_STRING,ERROR,*9999)
              ENDIF
            ELSE
              IF(DOP) THEN
                WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                WRITE(OP_STRING,
     '            '(''   Conductivity change of'',F12.6)') DSIGMA
                CALL WRITES(IODI,OP_STRING,ERROR,*9999)
              ENDIF

C***          Invariant part of fundamental solution
              DGREENSTATIC=DSIGMA/(4.0d0*PI)

C***          Transfer global parameters to local parameters (XPXE)
              ns=0
              nb=NBJ(1,ne)
              DO nn=1,NNT(nb)
                np=NPNE(nn,nb,ne)
                DO mk=1,NKT(nn,nb)
                  ns=ns+1
                  XE(ns,1)=XP(NKJE(mk,nn,1,ne),NVJE(nn,nb,1,ne),1,np)*
     '              SE(ns,nb,ne)
                  XE(ns,2)=XP(NKJE(mk,nn,2,ne),NVJE(nn,nb,2,ne),2,np)*
     '              SE(ns,nb,ne)
                  XE(ns,3)=XP(NKJE(mk,nn,3,ne),NVJE(nn,nb,3,ne),3,np)*
     '              SE(ns,nb,ne)
                ENDDO
              ENDDO
C***          Transfer global potential vector to element solution
C             vector (ZPZE)
C             ZE(ns,nhx) contains the dependent variable values
              ns=0
              nb=NBH(nh,1,ne)
              DO nn=1,NNT(nb)
                np=NPNE(nn,nb,ne)
                nv=NVHE(nn,nb,nh,ne)
                DO mk=1,NKT(nn,nb)
                  nk=NKHE(mk,nn,nh,ne)
                  ns=ns+1
                  IF((mk.EQ.NKT(0,nb)).AND.((KTYP93(1,nr).EQ.1).AND.
     '              (NKT(0,nb).GT.3))) THEN
                    ZE(ns,nhx)=0.0d0
                  ELSE IF(BEMCURVATURECORRECTION.AND.1.EQ.2.AND.
     '                (nk.EQ.2.OR.nk.EQ.3)) THEN
                    SUM=0.0d0
                    DO nk1=1,NKT(nn,nb)-1
                      SUM=SUM+CURVCORRECT(nk1,nk-1,nn,ne)*
     '                  ZP(nk1+1,nv,nhx,np,1)
                    ENDDO !nk1
                    ZE(ns,nhx)=(ZP(nk,nv,nh,np,1)+SUM)*SE(ns,nb,ne)
                  ELSE
                    ZE(ns,nhx)=ZP(nk,nv,nh,np,1)*SE(ns,nb,ne)
                  ENDIF
                ENDDO !mk
              ENDDO !nn

C***          Determine integration scheme to use for element ne
              CALL DIST_LOOSE(intscheme,NBJ(1,ne),NLL(1,ne),NNMIN,
     '          NPNE(1,1,ne),nr,NW(ne,2),DL,MINDIST,XP,XPFP,ERROR,
     '          *9999)
              IF(intscheme.NE.1) THEN
                NNMIN=0
              ENDIF

C***          Decide upon the appropriate basis for the integration
C             scheme
              CALL QUADBE(intscheme,NBJ(1,ne),nbbem,ERROR,*9999)
              nb1jp=NFBASE(1,NBASEF(NBJ(1,ne),nbbem))

C***          Setup adaptive integration information if nescessary.
              USEADAPINT=.FALSE.
              IF(intscheme.EQ.2.AND.NW(ne,2).NE.11.AND.
     '          NW(ne,2).NE.13) THEN
C***            Don't use this on distorted cubic linear elements.
C               Find the minimum distance in the element to the
C               singular point for Telles' rule.
                USEADAPINT=.TRUE.
                CALL TELLES(IBT,IDO,INP,20,NBJ(1,ne),NLL(1,ne),
     '            NW(ne,2),D,DL,1.0d-6,XE,XIMIN,XPFP,ERROR,*9999)
C***             Set up adaptive basis functions based on Telles rule
                nb1j=NBASEF(NBJ(1,ne),nbbem)
                nbuh=NBASEF(NBH(NH_LOC(1,nx),1,ne),nbbem)
                nbqh=NBASEF(NBH(NH_LOC(1,nx),2,ne),nbbem)
                CALL GAUSS11(IBT,IDO,INP,nb1j,nb1jp,nbqh,nbuh,NGAP,
     '            D,DETLOC,DET_ADAPT,PG_J,PG_Q,PG_U,XIG,XIG_J,XIG_Q,
     '            XIG_U,XIMIN,ERROR,*9999)
              ENDIF

              IF(DOP) THEN
                WRITE(OP_STRING,'(''   Basis function: '',I2)') nbbem
                CALL WRITES(IODI,OP_STRING,ERROR,*9999)
              ENDIF

C***          Calculate the element integrals for the current node
C             and dependent variable.
              ISP=0
              IF(intscheme.EQ.1) THEN !Element splitting
C***            Find number of split elements used at
C               nodes < NNSPLIT(nonode)
                DO nnsp=0,NNMIN-1
                  ISP=ISP+NDET(nb1jp,nnsp)
                ENDDO
              ENDIF

C***          Loop over number of split elements (if any)
              DO nsplit=1,NDET(nb1jp,NNMIN)
                nb2=nbbem+ISP
C***            Decide basis functions from the parent family
C               basis function for dependent (u)
                nbuhp=NFBASE(1,NBASEF(NBH(nh,1,ne),nbbem))

C***            nbuh and nb1j are the global basis functions
C               with the appropriate quadrature for the dependent
C               (H) and geometric (J) variables.
                nbuh=NBASEF(NBH(nh,1,ne),nb2)
                nb1j=NBASEF(NBJ(1,ne),nb2)

C***            set up the gauss point dependent arrays.
                DO ng=1,NGT(nb1j)
                  IF(USEADAPINT) THEN
                    XG1(1,1,ng)=DDOT(NST(nb1jp),PG_J(1,1,ng),1,
     '                XE(1,1),1)
                    XG1(2,1,ng)=DDOT(NST(nb1jp),PG_J(1,1,ng),1,
     '                XE(1,2),1)
                    XG1(3,1,ng)=DDOT(NST(nb1jp),PG_J(1,1,ng),1,
     '                XE(1,3),1)
                    XG1(1,2,ng)=DDOT(NST(nb1jp),PG_J(1,2,ng),1,
     '                XE(1,1),1)
                    XG1(2,2,ng)=DDOT(NST(nb1jp),PG_J(1,2,ng),1,
     '                XE(1,2),1)
                    XG1(3,2,ng)=DDOT(NST(nb1jp),PG_J(1,2,ng),1,
     '                XE(1,3),1)
                    XG1(1,4,ng)=DDOT(NST(nb1jp),PG_J(1,4,ng),1,
     '                XE(1,1),1)
                    XG1(2,4,ng)=DDOT(NST(nb1jp),PG_J(1,4,ng),1,
     '                XE(1,2),1)
                    XG1(3,4,ng)=DDOT(NST(nb1jp),PG_J(1,4,ng),1,
     '                XE(1,3),1)
                  ELSE
                    XG1(1,1,ng)=DDOT(NST(nb1jp),PG(1,1,ng,nb1j),1,
     '                XE(1,1),1)
                    XG1(2,1,ng)=DDOT(NST(nb1jp),PG(1,1,ng,nb1j),1,
     '                XE(1,2),1)
                    XG1(3,1,ng)=DDOT(NST(nb1jp),PG(1,1,ng,nb1j),1,
     '                XE(1,3),1)
                    XG1(1,2,ng)=DDOT(NST(nb1jp),PG(1,2,ng,nb1j),1,
     '                XE(1,1),1)
                    XG1(2,2,ng)=DDOT(NST(nb1jp),PG(1,2,ng,nb1j),1,
     '                XE(1,2),1)
                    XG1(3,2,ng)=DDOT(NST(nb1jp),PG(1,2,ng,nb1j),1,
     '                XE(1,3),1)
                    XG1(1,4,ng)=DDOT(NST(nb1jp),PG(1,4,ng,nb1j),1,
     '                XE(1,1),1)
                    XG1(2,4,ng)=DDOT(NST(nb1jp),PG(1,4,ng,nb1j),1,
     '                XE(1,2),1)
                    XG1(3,4,ng)=DDOT(NST(nb1jp),PG(1,4,ng,nb1j),1,
     '                XE(1,3),1)
                  ENDIF

C***              RG(ng) stores the Jacobian for a length or area
C                 integral at Gauss point ng.
C                 DXXI(nj,ni) contains the values of dXj/dPSIi at
C                 the Gauss point.
                  DXXI(1,1)=XG1(1,2,ng)
                  DXXI(2,1)=XG1(2,2,ng)
                  DXXI(3,1)=XG1(3,2,ng)
                  DXXI(1,2)=XG1(1,4,ng)
                  DXXI(2,2)=XG1(2,4,ng)
                  DXXI(3,2)=XG1(3,4,ng)

C***              Jacobian for 2D integral in 3D space
                  RG(ng)=DSQRT(
     '              (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))*
     '              (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))+
     '              (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))*
     '              (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))+
     '              (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1))*
     '              (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1)))


C!!! LKC - wrong way around??? Should be XPFP-XG1??
                  
C***              Calculate radius arrays
                  XR(1,ng)=XG1(1,1,ng)-XPFP(1)
                  XR(2,ng)=XG1(2,1,ng)-XPFP(2)
                  XR(3,ng)=XG1(3,1,ng)-XPFP(3)
                  RAD(ng)=DSQRT(XR(1,ng)*XR(1,ng)+
     '              XR(2,ng)*XR(2,ng)+XR(3,ng)*XR(3,ng))
                ENDDO !End ng loop

                IF(USEADAPINT) THEN
                  ns=0
                  DO nn=1,NNT(nbuhp) !Dependent variable loop
                    npnn=NPNE(nn,nbuhp,ne)
                    DO nk1=1,NKT(nn,nbuhp)
                      MK=NKHE(nk1,nn,nh,ne) !MK=0 at a distorted node
                      ns=ns+1
                      IF(MK.GT.0.AND.nk1.LE.MAX(NKH(nh,npnn,1,nr)
     '                  -KTYP93(1,nr),1)) THEN
                        SUMU1=0.0d0
                        SUMU2=0.0d0
                        SUMU3=0.0d0
                        DO ng=1,NGT(nbuh)
C***                      Evaluate element integrals
C                         DGREEN gives -dsigma/(4*pi*r^2) * (1/r)
C                         also multiplied by gauss weights etc
                          DGREEN_LOC=DGREENSTATIC*PG_U(ns,1,ng)*
     '                      RG(ng)*WG(ng,nbuh)*
     '                      DET_ADAPT(nbuhp,NNMIN,ng)/
     '                      (RAD(ng)*RAD(ng)*RAD(ng))

C!!! LKC check here
                          
                          SUMU1=SUMU1+DGREEN_LOC*(XR(2,ng)*XN(3,1)-
     '                      XR(3,ng)*XN(2,1))
                          SUMU2=SUMU2+DGREEN_LOC*(XR(3,ng)*XN(1,1)-
     '                      XR(1,ng)*XN(3,1))
                          SUMU3=SUMU3+DGREEN_LOC*(XR(1,ng)*XN(2,1)-
     '                      XR(2,ng)*XN(1,1))
                        ENDDO !End of ng loop
                        YD_LOCAL(nh,1)=YD_LOCAL(nh,1)+SUMU1*ZE(ns,nhx)
                        YD_LOCAL(nh,2)=YD_LOCAL(nh,2)+SUMU2*ZE(ns,nhx)
                        YD_LOCAL(nh,3)=YD_LOCAL(nh,3)+SUMU3*ZE(ns,nhx)
                      ENDIF !End of MK > 0 loop
                    ENDDO !End of nk1 loop
                  ENDDO !End of nn loop
                ELSE
                  ns=0
                  DO nn=1,NNT(nbuhp) !Dependent variable loop
                    npnn=NPNE(nn,nbuhp,ne)
                    DO nk1=1,NKT(nn,nbuhp)
                      MK=NKHE(nk1,nn,nh,ne) !MK=0 at a distorted node
                      ns=ns+1
                      IF(MK.GT.0.AND.nk1.LE.MAX(NKH(nh,npnn,1,nr)
     '                  -KTYP93(1,nr),1)) THEN
                        SUMU1=0.0d0
                        SUMU2=0.0d0
                        SUMU3=0.0d0
                        DO ng=1,NGT(nbuh)
C***                      Evaluate element integrals
C                         DGREEN gives -dsigma/(4*pi*r^2) * (1/r)
C                         also multiplied by gauss weights etc
                          DGREEN_LOC=DGREENSTATIC*PG(ns,1,ng,nbuh)*
     '                      RG(ng)*WG(ng,nbuh)*
     '                      DETLOC(nbuhp,NNMIN,ng,nsplit)/
     '                      (RAD(ng)*RAD(ng)*RAD(ng))

C!!! LKC check here
                          
                          SUMU1=SUMU1+DGREEN_LOC*(XR(2,ng)*XN(3,1)-
     '                      XR(3,ng)*XN(2,1))
                          SUMU2=SUMU2+DGREEN_LOC*(XR(3,ng)*XN(1,1)-
     '                      XR(1,ng)*XN(3,1))
                          SUMU3=SUMU3+DGREEN_LOC*(XR(1,ng)*XN(2,1)-
     '                      XR(2,ng)*XN(1,1))
                        ENDDO !End of ng loop
                        YD_LOCAL(nh,1)=YD_LOCAL(nh,1)+SUMU1*ZE(ns,nhx)
                        YD_LOCAL(nh,2)=YD_LOCAL(nh,2)+SUMU2*ZE(ns,nhx)
                        YD_LOCAL(nh,3)=YD_LOCAL(nh,3)+SUMU3*ZE(ns,nhx)
                      ENDIF !End of MK > 0 loop
                    ENDDO !End of nk1 loop
                  ENDDO !End of nn loop
                ENDIF

                ISP=ISP+nsplit
              ENDDO !End of nsplit loop
            ENDIF !conductivity change
          ENDIF !master or external
        ENDDO !ne
        H_FIELD(1)=H_FIELD(1)+YD_LOCAL(1,1)
        H_FIELD(2)=H_FIELD(2)+YD_LOCAL(1,2)
        H_FIELD(3)=H_FIELD(3)+YD_LOCAL(1,3)
      ENDIF !magvolume

      IF(MAGDIPOLE.AND.(nr.EQ.NRLISTL(1))) THEN
C***    Only do once - for first region by default
        DO n_dipole=1,NDIPOLES(nr)
          CALL GETDIPOLE(DIPOLE_CEN_NTIME,DIPOLE_DIR_NTIME,n_dipole,
     '      nr,CENTRE,DIPOLE_CEN,DIPOLE_DIR,DIRECTION,LOC_TIME,ERROR,
     '      *9999)

C***      Calculate radial components and radius
C         r is from field point to source point
          XR(1,1)=XPFP(1)-CENTRE(1)
          XR(2,1)=XPFP(2)-CENTRE(2)
          XR(3,1)=XPFP(3)-CENTRE(3)
          RAD(1)=DSQRT(XR(1,1)*XR(1,1)+XR(2,1)*XR(2,1)+
     '      XR(3,1)*XR(3,1))

          IF(RAD(1).GT.ZERO_TOL) THEN
C***        p X R/(4 pi r^3)
            SUMXG=1.0d0/(4.0d0*PI*RAD(1)*RAD(1)*RAD(1))
            H_FIELD(1)=H_FIELD(1)+(DIRECTION(2)*XR(3,1)-
     '        DIRECTION(3)*XR(2,1))*SUMXG
            H_FIELD(2)=H_FIELD(2)+(DIRECTION(3)*XR(1,1)-
     '        DIRECTION(1)*XR(3,1))*SUMXG
            H_FIELD(3)=H_FIELD(3)+(DIRECTION(1)*XR(2,1)-
     '        DIRECTION(2)*XR(1,1))*SUMXG
          ENDIF !radius
        ENDDO !n_dipole
      ENDIF !magdipole


      CALL EXITS('MAGSOLOPTI')
      RETURN
9999  CALL ERRORS('MAGSOLOPTI',ERROR)
      CALL EXITS('MAGSOLOPTI')
      RETURN 1
      END


