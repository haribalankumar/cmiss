      SUBROUTINE MAGSOL(DIPOLE_CEN_NTIME,DIPOLE_DIR_NTIME,IBT,IDO,INP,
     '  NBH,NBJ,NDET,NDIPOLES,NEELEM,NENP,NGAP,NHE,NHP,NKH,NKHE,NKJE,
     '  NP_INTERFACE,NLL,NPF,NPNE,NPNODE,NRLIST,NRE,NVHE,NVHP,NVJE,NW,
     '  nx,NYNE,NYNP,CE,CURVCORRECT,DETLOC,DET_ADAPT,DIPOLE_CEN,
     '  DIPOLE_DIR,DL,H_FIELD,LOC_TIME,PG,PG_J,PG_Q,PG_U,RAD,RG,SE,WG,
     '  XA,XE,XG1,XIG,XIG_J,XIG_Q,XIG_U,XN,XP,XPFP,XR,YD_LOCAL,YP,ZA,ZE,
     '  ZP,MAGDIPOLE,MAGVOLUME,VPOTENTIAL,ERROR,*)

C#### Subroutine: MAGSOL
C###  Description:
C###    MAGSOL calculates the magnetic field
C###    that results from a potential field throughout a
C###    domain by putting the domain into a box and doing
C###    domain solutions at grid points. There are two magnetic
C###    sources, the first is the primary current source and the
C###    second is the field generated by conductivity changes across
C###    region boundaries.
C**** Created by Martin Buist - December 2001

      IMPLICIT NONE

      INCLUDE 'b00.cmn'
      INCLUDE 'b01.cmn'
      INCLUDE 'b10.cmn'
      INCLUDE 'bem000.cmn'
      INCLUDE 'cbdi02.cmn'
      INCLUDE 'coup00.cmn'
      INCLUDE 'geom00.cmn'
      INCLUDE 'loc00.inc'
      INCLUDE 'loc00.cmn'
      INCLUDE 'tol00.cmn'

!     Parameter List
      INTEGER DIPOLE_CEN_NTIME(NDIPOLEM,NRM),
     '  DIPOLE_DIR_NTIME(NDIPOLEM,NRM),IBT(3,NIM,NBFM),
     '  IDO(NKM,NNM,0:NIM,NBFM),INP(NNM,NIM,NBFM),NBH(NHM,NCM,NEM),
     '  NBJ(NJM,NEM),NDET(NBFM,0:NNM),NDIPOLES(NRM),
     '  NEELEM(0:NE_R_M,0:NRM),NENP(NPM,0:NEPM,0:NRM),NGAP(NIM,NBM),
     '  NHE(NEM),NHP(NPM,0:NRM),NKH(NHM,NPM,NCM,0:NRM),
     '  NKHE(NKM,NNM,NHM,NEM),NKJE(NKM,NNM,NJM,NEM),
     '  NP_INTERFACE(0:NPM,0:3),NLL(12,NEM),NPF(9,NFM),
     '  NPNE(NNM,NBFM,NEM),NPNODE(0:NP_R_M,0:NRM),NRLIST(0:NRM),
     '  NRE(NEM),NVHE(NNM,NBFM,NHM,NEM),NVHP(NHM,NPM,NCM,0:NRM),
     '  NVJE(NNM,NBFM,NJM,NEM),NW(NEM,3),nx,
     '  NYNE(NAM,NHM,0:NRCM,NCM,NEM),
     '  NYNP(NKM,NVM,NHM,NPM,0:NRCM,NCM,NRM)
      REAL*8 CE(NMM,NEM),CURVCORRECT(2,2,NNM,NEM),
     '  DETLOC(NBFM,0:NNM,NGM,6),DET_ADAPT(NBFM,0:NNM,NGM),
     '  DIPOLE_CEN(4,0:NDIPTIMM,NDIPOLEM,NRM),
     '  DIPOLE_DIR(4,0:NDIPTIMM,NDIPOLEM,NRM),DL(3,NLM),H_FIELD(*),
     '  LOC_TIME,PG(NSM,NUM,NGM,NBM),PG_J(NSM,NUM,NGM),
     '  PG_Q(NSM,NUM,NGM),PG_U(NSM,NUM,NGM),RAD(NGM),RG(NGM),
     '  SE(NSM,NBFM,NEM),WG(NGM,NBM),XA(NAM,NJM,NEM),XE(NSM,NJM),
     '  XG1(NJM,NUM,NGM),XIG(NIM,NGM,NBM),XIG_J(NIM,NGM),XIG_Q(NIM,NGM),
     '  XIG_U(NIM,NGM),XN(NJM,NGM),XP(NKM,NVM,NJM,NPM),XPFP(*),
     '  XR(NJM,NGM),YD_LOCAL(9,9),YP(NYM,NIYM),ZA(NAM,NHM,NCM,NEM),
     '  ZE(NSM,NHM),ZP(NKM,NVM,NHM,NPM,NCM)
      CHARACTER ERROR*(*)
      LOGICAL MAGDIPOLE,MAGVOLUME,VPOTENTIAL
!     Local Variables
      INTEGER intscheme,ISP,nb2,nbbem,nb1j,nb1jp,nbqh,nbuh,nbuhp,
     '  n_dipole,ne,ng,nh,nhx,ni,NITB,nj,nnmin,nnsp,noelem,np,nr,
     '  NRLIST_LOCAL(0:99),nrr,ns,nsplit,NU1(0:3)
      REAL*8 CENTRE(3),D(2),DIRECTION(3),DSIGMA,DXXI(3,3),MINDIST,SUMXG,
     '  XIMIN(2)
      LOGICAL DUMMY,INTERFACE,USEADAPINT

      DATA NU1/1,2,4,7/

      CALL ENTERS('MAGSOL',*9999)

C***  Initialise the magnetic field
      DO nj=1,NJT
        H_FIELD(nj)=0.0d0
      ENDDO !nj

C      XPFP(1)=1.76776695296637d0*3.1d0/5.0d0
C      XPFP(2)=3.06186217847897d0*3.1d0/5.0d0
C      XPFP(3)=3.53553390593274d0*3.1d0/5.0d0

C***  Check to see if the BE problem is a coupled problem and
C     sort out which region boundaries need to be dealt with
      IF(IS_COUPLED(nx)) THEN
        DO nrr=1,COUP_NRLIST(0,nx)
          NRLIST_LOCAL(nrr)=COUP_NRLIST(nrr,nx)
        ENDDO !nrr
        NRLIST_LOCAL(0)=COUP_NRLIST(0,nx)
      ELSE
        NRLIST_LOCAL(0)=1
        NRLIST_LOCAL(1)=NRLIST(1)
      ENDIF
C***  Diagnostics
      IF(DOP) THEN
        WRITE(OP_STRING,'('' Number of regions is '',I4)')
     '    NRLIST_LOCAL(0)
        CALL WRITES(IODI,OP_STRING,ERROR,*9999)
        DO nrr=1,NRLIST_LOCAL(0)
          WRITE(OP_STRING,'(''   Region: '',I4)') NRLIST_LOCAL(nrr)
          CALL WRITES(IODI,OP_STRING,ERROR,*9999)
        ENDDO !nrr
      ENDIF

C LKC Committed 14-JAN-2011
C
C!!! LKC 27-JAN-2009. I don't think this is correct. This is not really
C!!! calculating an outward normal is it calculating a normal vector
C!!! between the field point/sensor (XPFP) and the origin. The calculation of XN now takes
C!!! place inside XEPGKMAGSOL.f
        
C***  Find the unit outward normal to the field point.

C      XN(1,1)=XPFP(1)/
C     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)
C      XN(2,1)=XPFP(2)/
C     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)
C      XN(3,1)=XPFP(3)/
C     '  DSQRT(XPFP(1)**2.0d0+XPFP(2)**2.0d0+XPFP(3)**2.0d0)

      
C***  Loop over the problem regions
      DO nrr=1,NRLIST_LOCAL(0)
        nr=NRLIST_LOCAL(nrr)

C***    Calculate the magnetic field contribution from the
C       boundary element surfaces
        IF(MAGVOLUME) THEN
C***      Transfer dependent variable to ZP
          CALL YPZP(1,NBH,NEELEM,NHE,NHP(1,nr),NKH(1,1,1,nr),NPNODE,nr,
     '      NVHP(1,1,1,nr),nx,NYNE,NYNP,YP,ZA,ZP,ERROR,*9999)

          DO nj=1,NJT
            YD_LOCAL(1,nj)=0.0d0
          ENDDO
          DO noelem=1,NEELEM(0,nr)
            ne=NEELEM(noelem,nr)
            np=NPNE(1,NBJ(1,ne),ne)
            IF((NP_INTERFACE(np,1).EQ.nr).OR.
     '        (NP_INTERFACE(np,0).EQ.1)) THEN
              INTERFACE=.FALSE.

C***          Assumed by standard Laplace equation
              IF(IGREN(nr).EQ.1) CE(1,ne)=1.0d0
              IF(IGREN(nr).EQ.2) CE(1,ne)=1.0d0

C***          Calculate conductivity change
              IF(NP_INTERFACE(np,0).EQ.1) THEN
                DSIGMA=CE(1,ne) ! -zero outside
              ELSE
                DSIGMA=CE(1,ne)-CE(1,NENP(np,1,NP_INTERFACE(np,2)))
              ENDIF

C***          If the conductivities are the same, there is no
C             magnetic field contribution
              IF(DABS(DSIGMA).LT.ZERO_TOL) THEN
                !do nothing
                IF(DOP) THEN
                  WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                  WRITE(OP_STRING,'(''   No conductivity change'')')
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF
              ELSE
                IF(DOP) THEN
                  WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                  WRITE(OP_STRING,
     '              '(''   Conductivity change of'',F12.6)') DSIGMA
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF

C***            Transfer global geom parameters to local parameters
                CALL XPXE(NBJ(1,ne),NKJE(1,1,1,ne),NPF(1,1),
     '            NPNE(1,1,ne),NRE(ne),NVJE(1,1,1,ne),SE(1,1,ne),
     '            XA(1,1,ne),XE,XP,ERROR,*9999)
C***            Transfer global potential vector to element solution
C               vector
                CALL ZPZE(NBH(1,1,ne),1,NHE(ne),NKHE(1,1,1,ne),NPF(1,1),
     '            NPNE(1,1,ne),nr,NVHE(1,1,1,ne),NW(ne,2),nx,
     '            CURVCORRECT(1,1,1,ne),SE(1,1,ne),ZA(1,1,1,ne),ZE,ZP,
     '            ERROR,*9999)
                !ZE(ns,nhx) contains the dependent variable values

C***            Determine integration scheme to use for element ne
                CALL DIST_LOOSE(intscheme,NBJ(1,ne),NLL(1,ne),NNMIN,
     '            NPNE(1,1,ne),nr,NW(ne,2),DL,MINDIST,XP,XPFP,ERROR,
     '            *9999)

                IF(intscheme.NE.1) THEN
                  NNMIN=0
                ENDIF

C***            Decide upon the appropriate basis for the integration
C               scheme
                CALL QUADBE(intscheme,NBJ(1,ne),nbbem,ERROR,*9999)
                nb1jp=NFBASE(1,NBASEF(NBJ(1,ne),nbbem))
                NITB=NIT(nb1jp)

C***            Setup adaptive integration information if nescessary.
                USEADAPINT=.FALSE.
                IF(intscheme.EQ.2.AND.NW(ne,2).NE.11.AND.
     '            NW(ne,2).NE.13) THEN
C***              Don't use this on distorted cubic linear elements.
C                 Find the minimum distance in the element to the
C                 singular point for Telles' rule.
                  USEADAPINT=.TRUE.
                  CALL TELLES(IBT,IDO,INP,20,NBJ(1,ne),NLL(1,ne),
     '              NW(ne,2),D,DL,1.0d-6,XE,XIMIN,XPFP,ERROR,*9999)
C***               Set up adaptive basis functions based on Telles rule
                   nb1j=NBASEF(NBJ(1,ne),nbbem)
                   nbuh=NBASEF(NBH(NH_LOC(1,nx),1,ne),nbbem)
                   nbqh=NBASEF(NBH(NH_LOC(1,nx),2,ne),nbbem)
                   CALL GAUSS11(IBT,IDO,INP,nb1j,nb1jp,nbqh,nbuh,NGAP,
     '               D,DETLOC,DET_ADAPT,PG_J,PG_Q,PG_U,XIG,XIG_J,XIG_Q,
     '               XIG_U,XIMIN,ERROR,*9999)
                ENDIF

                IF(DOP) THEN
                  WRITE(OP_STRING,'(''   Basis function: '',I2)') nbbem
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF

C***            Calculate the element integrals for the current node
C               and dependent variable.
                ISP=0
                IF(intscheme.EQ.1) THEN !Element splitting
C***              Find number of split elements used at
C                 nodes < NNSPLIT(nonode)
                  DO nnsp=0,NNMIN-1
                    ISP=ISP+NDET(nb1jp,nnsp)
                  ENDDO
                ENDIF

C***            Loop over dependent variables
                DO nhx=1,NHE(ne)
                  nh=NH_LOC(nhx,nx)

C***              Loop over number of split elements (if any)
                  DO nsplit=1,NDET(nb1jp,NNMIN)
                    nb2=nbbem+ISP
C***                Decide basis functions from the parent family
C                   basis function for dependent (u) and normal
C                   derivative (q).
                    nbuhp=NFBASE(1,NBASEF(NBH(nh,1,ne),nbbem))

C***                nbuh,nbqh and nb1j are the global basis functions
C                   with the appropriate quadrature for the dependent
C                   (H), normal derivative (Q) and geometric (J)
C                   variables.
                    nbuh=NBASEF(NBH(nh,1,ne),nb2)
                    nbqh=NBASEF(NBH(nh,2,ne),nb2)
                    nb1j=NBASEF(NBJ(1,ne),nb2)

C***                set up the gauss point dependent arrays.
                    DO ng=1,NGT(nb1j)
                      IF(USEADAPINT) THEN
                        DO nj=1,NJ_LOC(NJL_GEOM,0,nr)
                          DO ni=0,NITB
                            SUMXG=0.0d0
                            DO ns=1,NST(nb1jp)
                              SUMXG=SUMXG+PG_J(ns,NU1(ni),ng)*XE(ns,nj)
                            ENDDO !ns
                            XG1(nj,NU1(ni),ng)=SUMXG
                          ENDDO !ni
                        ENDDO !nj
                      ELSE
                        DO nj=1,NJ_LOC(NJL_GEOM,0,nr)
                          DO ni=0,NITB
                            SUMXG=0.0d0
                            DO ns=1,NST(nb1jp)
                              SUMXG=SUMXG+PG(ns,NU1(ni),ng,nb1j)*
     '                          XE(ns,nj)
                            ENDDO !ns
                            XG1(nj,NU1(ni),ng)=SUMXG
                          ENDDO !ni
                        ENDDO !nj
                      ENDIF
C***                  RG(ng) stores the Jacobian for a length or area
C                     integral at Gauss point ng.
C                     DXXI(nj,ni) contains the values of dXj/dPSIi at
C                     the Gauss point.
                      DO ni=1,NITB
                        DO nj=1,NJ_LOC(NJL_GEOM,0,nr)
                         DXXI(nj,ni)=XG1(nj,NU1(ni),ng)
                        ENDDO !nj
                      ENDDO !ni
C***                  Jacobian for 2D integral in 3D space
                      RG(ng)=DSQRT(
     '                  (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))*
     '                  (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))+
     '                  (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))*
     '                  (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))+
     '                  (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1))*
     '                  (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1)))
                    ENDDO !End ng loop

                    IF(USEADAPINT) THEN
                      CALL XEPGKMAGSOL(nb1j,nbuh,nbuhp,ne,nh,NHE(ne),
     &                  nhx,NKHE(1,1,1,ne),NKH(1,1,1,nr),nnmin,NPNE(1,1,
     &                  ne),nr,NW,DET_ADAPT,DSIGMA,PG_U,RAD,RG,WG,XG1,
     &                  XN,XPFP,XR,YD_LOCAL,ZE,ERROR,*9999)                      
                    ELSE
                      CALL XEPGKMAGSOL(nb1j,nbuh,nbuhp,ne,nh,NHE(ne),
     &                  nhx,NKHE(1,1,1,ne),NKH(1,1,1,nr),nnmin,NPNE(1,1,
     &                  ne),nr,NW,DETLOC(1,0,1,nsplit),DSIGMA,PG(1,1,1,
     &                  nbuh),RAD,RG,WG,XG1,XN,XPFP,XR,YD_LOCAL,ZE,
     &                  ERROR,*9999)
                    ENDIF
                    ISP=ISP+nsplit
                  ENDDO !End of nsplit loop

                ENDDO !End of nh loop
              ENDIF !conductivity change
            ENDIF !master or external
          ENDDO !ne

C LKC Committed 14-JAN-2011
C          
C LKC 27-JAN-2009 H_FIELD should be already zero at this point          
C          H_FIELD(1)=H_FIELD(1)+YD_LOCAL(1,1)
C          H_FIELD(2)=H_FIELD(2)+YD_LOCAL(1,2)
C          H_FIELD(3)=H_FIELD(3)+YD_LOCAL(1,3)
          H_FIELD(1)=-YD_LOCAL(1,1)
          H_FIELD(2)=-YD_LOCAL(1,2)
          H_FIELD(3)=-YD_LOCAL(1,3)
        ENDIF !magvolume

C*** Calculate the mangetic field due to a diple in freespace        
        IF(MAGDIPOLE) THEN
          DO n_dipole=1,NDIPOLES(nr)
            CALL GETDIPOLE(DIPOLE_CEN_NTIME,DIPOLE_DIR_NTIME,n_dipole,
     &        nr,CENTRE,DIPOLE_CEN,DIPOLE_DIR,DIRECTION,LOC_TIME,ERROR,
     &        *9999)
            
C            WRITE(OP_STRING,'('' MAGSOL center '',F8.2,3F15.9)')
C     &        LOC_TIME,(CENTRE(nj),nj=1,3)
C            CALL WRITES(IODI,OP_STRING,ERROR,*9999)
C            WRITE(OP_STRING,'('' MAGSOL orient'',F8.2,3F15.9)')
C     &        LOC_TIME,(DIRECTION(nj),nj=1,3)
C            CALL WRITES(IODI,OP_STRING,ERROR,*9999)


C <<-- radial == distance between the sensor and source.

C***        Calculate radial components and radius
C***        XPFP is the sensor location            
            SUMXG=0.0d0
            DO nj=1,NJT
              !r is from field point to source point
              XR(nj,1)=XPFP(nj)-CENTRE(nj)
              SUMXG=SUMXG+(XR(nj,1)*XR(nj,1)) !r*r
            ENDDO !nj
            RAD(1)=DSQRT(SUMXG)

            IF(RAD(1).GT.ZERO_TOL) THEN
C***          p X R/(4 pi r^3)
              SUMXG=1.0d0/(4.0d0*PI*RAD(1)*RAD(1)*RAD(1))
              H_FIELD(1)=H_FIELD(1)+(DIRECTION(2)*XR(3,1)-
     '          DIRECTION(3)*XR(2,1))*SUMXG
              H_FIELD(2)=H_FIELD(2)+(DIRECTION(3)*XR(1,1)-
     '          DIRECTION(1)*XR(3,1))*SUMXG
              H_FIELD(3)=H_FIELD(3)+(DIRECTION(1)*XR(2,1)-
     '          DIRECTION(2)*XR(1,1))*SUMXG
            ENDIF !radius
          ENDDO !n_dipole
        ENDIF !magdipole

C***    Calculate the magnetic vector potential
        IF(VPOTENTIAL) THEN
C***      Transfer dependent variable to ZP
          CALL YPZP(1,NBH,NEELEM,NHE,NHP(1,nr),NKH(1,1,1,nr),NPNODE,nr,
     '      NVHP(1,1,1,nr),nx,NYNE,NYNP,YP,ZA,ZP,ERROR,*9999)

          DO nj=1,NJT
            YD_LOCAL(1,nj)=0.0d0
          ENDDO
          DO noelem=1,NEELEM(0,nr)
            ne=NEELEM(noelem,nr)
            np=NPNE(1,NBJ(1,ne),ne)
           IF((NP_INTERFACE(np,1).EQ.nr).OR.
     '         (NP_INTERFACE(np,0).EQ.1)) THEN
              INTERFACE=.FALSE.

C***          Assumed by standard Laplace equation
              IF(IGREN(nr).EQ.1) CE(1,ne)=1.0d0
              IF(IGREN(nr).EQ.2) CE(1,ne)=1.0d0

C***          Calculate conductivity change
              IF(NP_INTERFACE(np,0).EQ.1) THEN
                DSIGMA=CE(1,ne) ! -zero outside
              ELSE
                DSIGMA=CE(1,ne)-CE(1,NENP(np,1,NP_INTERFACE(np,2)))
              ENDIF

C***          If the conductivities are the same, there is no
C             magnetic field contribution
              IF(DABS(DSIGMA).LT.ZERO_TOL) THEN
                !do nothing
                IF(DOP) THEN
                  WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                  WRITE(OP_STRING,'(''   No conductivity change'')')
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF
              ELSE
                IF(DOP) THEN
                  WRITE(OP_STRING,'('' Element '',I8,'':'')') ne
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                  WRITE(OP_STRING,
     '              '(''   Conductivity change of'',F12.6)') DSIGMA
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF

C***            Transfer global geom parameters to local parameters
                CALL XPXE(NBJ(1,ne),NKJE(1,1,1,ne),NPF(1,1),
     '            NPNE(1,1,ne),NRE(ne),NVJE(1,1,1,ne),SE(1,1,ne),
     '            XA(1,1,ne),XE,XP,ERROR,*9999)
C***            Transfer global potential vector to element solution
C               vector
                CALL ZPZE(NBH(1,1,ne),1,NHE(ne),NKHE(1,1,1,ne),NPF(1,1),
     '            NPNE(1,1,ne),nr,NVHE(1,1,1,ne),NW(ne,2),nx,
     '            CURVCORRECT(1,1,1,ne),SE(1,1,ne),ZA(1,1,1,ne),ZE,ZP,
     '            ERROR,*9999)
                !ZE(ns,nhx) contains the dependent variable values

C***            Determine integration scheme to use for element ne
                DUMMY=ADAPINT
                ADAPINT=.FALSE.
                CALL DIST(intscheme,NBJ(1,ne),NLL(1,ne),nnmin,
     '            NPNE(1,1,ne),nr,NW(ne,2),DL,MINDIST,XP,XPFP,ERROR,
     '            *9999)
                ADAPINT=DUMMY

C***            No splitting or adaptive int. implemented here -
C               most points will not be near the boundary
                IF(intscheme.EQ.1) THEN
                  intscheme=3
                ELSEIF(intscheme.EQ.2) THEN
                  intscheme=3
                ENDIF
                IF(DOP) THEN
                  WRITE(OP_STRING,'(''   Integration scheme: '',I2)')
     '              intscheme
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF

C***            Decide upon the appropriate basis for the integration
C               scheme
                CALL QUADBE(intscheme,NBJ(1,ne),nbbem,ERROR,*9999)
                nb1jp=NFBASE(1,NBASEF(NBJ(1,ne),nbbem))
                NITB=NIT(nb1jp)
                IF(DOP) THEN
                  WRITE(OP_STRING,'(''   Basis function: '',I2)') nbbem
                  CALL WRITES(IODI,OP_STRING,ERROR,*9999)
                ENDIF

C***            Loop over dependent variables
                DO nhx=1,NHE(ne)
                  nh=NH_LOC(nhx,nx)

C***              Decide basis functions from the parent family basis
C                 function for dependent (u).
                  nbuhp=NFBASE(1,NBASEF(NBH(nh,1,ne),nbbem))

C***              nbuh and nb1j are the global
C                 basis functions with the appropriate quadrature
C                 for the dependent (H) and geometric (J) variables.
                  nbuh=NBASEF(NBH(nh,1,ne),nbbem)
                  nb1j=NBASEF(NBJ(1,ne),nbbem)

C***              set up the gauss point dependent arrays.
                  DO ng=1,NGT(nb1j)
                    DO nj=1,NJ_LOC(NJL_GEOM,0,nr)
                      DO ni=0,NITB
                        SUMXG=0.0d0
                        DO ns=1,NST(nb1jp)
                          SUMXG=SUMXG+PG(ns,NU1(ni),ng,nb1j)*XE(ns,nj)
                        ENDDO !ns
                        XG1(nj,NU1(ni),ng)=SUMXG
                      ENDDO !ni
                    ENDDO !nj
C***                RG(ng) stores the Jacobian for a length or area
C                   integral at Gauss point ng.
C                   DXXI(nj,ni) contains the values of dXj/dPSIi at
C                   the Gauss point.
                    DO ni=1,NITB
                      DO nj=1,NJ_LOC(NJL_GEOM,0,nr)
                       DXXI(nj,ni)=XG1(nj,NU1(ni),ng)
                      ENDDO !nj
                    ENDDO !ni
                    IF(NITB.EQ.1) THEN
C***                  Jacobian for 1D integral in 2D space
                      RG(ng)=DSQRT(DXXI(1,1)*DXXI(1,1)+
     '                  DXXI(2,1)*DXXI(2,1))
                    ELSE !Calculate cross product of 2 tangent vectors
C***                  Jacobian for 2D integral in 3D space
                      RG(ng)=DSQRT(
     '                  (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))*
     '                  (DXXI(2,1)*DXXI(3,2)-DXXI(2,2)*DXXI(3,1))+
     '                  (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))*
     '                  (DXXI(1,2)*DXXI(3,1)-DXXI(1,1)*DXXI(3,2))+
     '                  (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1))*
     '                  (DXXI(1,1)*DXXI(2,2)-DXXI(1,2)*DXXI(2,1)))
                    ENDIF
C***                Find the unit outward normal.
                    CALL NORMAL(ne,nr,NW,XG1(1,1,ng),XN(1,ng),INTERFACE,
     '                ERROR,*9999)
                  ENDDO !End ng loop

                  CALL XEPGKMAGSOL2(nb1j,nbuh,nbuhp,nh,NHE(ne),nhx,
     '              NKHE(1,1,1,ne),NKH(1,1,1,nr),NPNE(1,1,ne),nr,
     '              DSIGMA,PG(1,1,1,nbuh),RAD,RG,WG,XG1,XPFP,XR,
     '              YD_LOCAL,ZE,ERROR,*9999)

                ENDDO !End of nh loop
              ENDIF !conductivity change
            ENDIF !master or external
          ENDDO !ne
          H_FIELD(1)=H_FIELD(1)+YD_LOCAL(1,1)
          H_FIELD(2)=H_FIELD(2)+YD_LOCAL(1,2)
          H_FIELD(3)=H_FIELD(3)+YD_LOCAL(1,3)
        ENDIF !vpotential
      ENDDO !nrr

      IF(VPOTENTIAL) THEN
C***    The vector potential lies the radial (normal) direction
        H_FIELD(1)=H_FIELD(1)*XPFP(1)/DSQRT(XPFP(1)**2+XPFP(2)**2
     '    +XPFP(3)**2)
        H_FIELD(2)=H_FIELD(2)*XPFP(2)/DSQRT(XPFP(1)**2+XPFP(2)**2
     '    +XPFP(3)**2)
        H_FIELD(3)=H_FIELD(3)*XPFP(3)/DSQRT(XPFP(1)**2+XPFP(2)**2
     '    +XPFP(3)**2)
      ENDIF

C      WRITE(*,*) H_FIELD(1),H_FIELD(2),H_FIELD(3)

      CALL EXITS('MAGSOL')
      RETURN
9999  CALL ERRORS('MAGSOL',ERROR)
      CALL EXITS('MAGSOL')
      RETURN 1
      END


