#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "fetriangle.h"

/*
 * flip3D.c
 * ========
 *
 * Routines added by R.G.Boyes for use in ALE code.
 */ 

#define FALSE 0
#define TRUE  1
#define SMALL 1.0e-12

/* Triple scalar product macro */
#define TSP(a,b,c) \
  (a.x*b.y*c.z - a.x*c.y*b.z + b.x*c.y*a.z \
  -b.x*a.y*c.z + c.x*a.y*b.z - c.x*b.y*a.z )

/* 3x3 Determinant macro */
#define DET_3X3(a11,a12,a13,a21,a22,a23,a31,a32,a33) \
               (a11*a22*a33 - a11*a32*a23 + a21*a32*a13  \
               -a21*a12*a33 + a31*a12*a23 - a31*a22*a13)

/* Fortran functions accessed */
#if defined(unix) || defined(_AIX) || defined (WIN32)
#  define DGETRF dgetrf_
#  define DGETRS dgetrs_  
#endif

void DGETRF( int *M, int *N, double *A, int *LDA, int *IPIV, int *INFO );
void DGETRS( char *TRANS, int *N, int *NRHS, double *A, int *LDA, int *IPIV,
	     double *B, int *LDB, int *INFO );

struct tet_type {
  int              vert[4];               /* Nodes of tet */
  int              indx;                  /* Tet number */
  double           x,y,z,rsq;             /* Circumcentre info */
  struct tet_type *nbor[4],*next,*prev;   /* Connections */
};
   
typedef struct tet_type TET_TYPE;
typedef struct {
  double x,y,z;
} Pvector;

static TET_TYPE *tet_head = NULL,
  *tet_tail,*flip3_next_tet;
static Pvector  *nodePos = NULL;

static double ALE_zero_tol;

/****************** Prototype Declarations ********************/
static TET_TYPE *Create_Tet(int *err_Flag,char *err_StringC);
static void Add_Tet(TET_TYPE *e);
static void Delete_Tet(TET_TYPE *goner);
static void DestroyTetList(void);
static void Get_Circumdata3D(TET_TYPE *tet);
static int  FoundOrder3Edge(TET_TYPE *tet,int ineib,TET_TYPE **teta,
                           TET_TYPE **tetb,TET_TYPE **tetc,
                           int *axisa,int *axisb);
static int  FaceIsDelaunay(TET_TYPE *tet,int ineib);
static int  AssemblyIsConvex(TET_TYPE *tet,int ineib);
static void FlipFaceToEdge(TET_TYPE *tet,int ineib,int *err_Flag,char *err_StringC);
static void FlipEdgeToFace(TET_TYPE *teta,TET_TYPE *tetb, TET_TYPE *tetc,
                           int axisa, int axisb, int *err_Flag,
                           char *err_StringC);
static void flip3(int *ntet,int *err_Flag,char *err_StringC);

/************************************************************/

static TET_TYPE *Create_Tet(int *err_Flag,char *err_StringC)
{
  TET_TYPE *p;
  
  p = (TET_TYPE *) malloc(sizeof(TET_TYPE));
  if (p == NULL) {
   *err_Flag = 1;
    strcpy(err_StringC,">>Create_Tet failed");
    return(NULL);
  }
  p->next = NULL;
  return p;
}

static void Add_Tet(TET_TYPE *e)
{
  TET_TYPE *p;

  if (tet_head == NULL) {
    tet_tail = e;
    tet_head = e;
    e->prev  = NULL;
  } 
  else {	
    p        = tet_tail;
    tet_tail = p->next = e;
    e->prev  = p; 
  }
}

static void Delete_Tet(TET_TYPE *goner)
{
  if ((goner == tet_head) && (goner == tet_tail)) {
    free(goner);
    goner = NULL;
    tet_head = NULL;
    tet_tail = NULL;
  }
  else if (goner == tet_head) {
    tet_head          = goner->next;
    goner->next->prev = NULL;
    free(goner);
    goner = NULL;
  }
  else if (goner == tet_tail) {
    tet_tail          = goner->prev;
    goner->prev->next = NULL;
    free(goner);
    goner = NULL;
  } 
  else {
    goner->next->prev = goner->prev;
    goner->prev->next = goner->next;
    free(goner);
    goner = NULL;
  }  
}

static void DestroyTetList()
{
  TET_TYPE *tet;
  
  tet = tet_head;
  while(tet->next != NULL) {
    tet = tet->next;
    Delete_Tet(tet->prev);
  }
  Delete_Tet(tet);
}

static void Get_Circumdata3D(TET_TYPE *tet)
{
/*
 * To calculate the centre of a sphere generated by the vertices
 * of a tetrahedron, it is necessary to solve the following system
 * of equations:
 *
 * | x2-x1 y2-y1 z2-z1 ||i|   |1/2(x2^2+ y2^2+ z2^2- x1^2- y1^2- z1^2)|
 * | x3-x1 y3-y1 z3-z1 ||j| = |1/2(x3^2+ y3^2+ z3^2- x1^2- y1^2- z1^2)|
 * | x4-x1 y4-y1 z4-z1 ||k|   |1/2(x4^2+ y4^2+ z4^2- x1^2- y1^2- z1^2)|
 *
 * Where i,j,k are the x,y,z positions of the circumball centre, and
 * x1,y2,z3 etc are the x,y,z positions of vertices 1,2,3 of the
 * tetrahedron
 */
  
  double  x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4;
  double  A[9];
  double  dx,dy,dz,sq;
  double  b[3];
  double  vol;
  int     m,n,nrhs,ipiv[3],info;
  char   *trans = "N";
  
  /* Get points from tet */
  
  x1 = nodePos[tet->vert[0]].x;
  x2 = nodePos[tet->vert[1]].x;  
  x3 = nodePos[tet->vert[2]].x;  
  x4 = nodePos[tet->vert[3]].x; 
  y1 = nodePos[tet->vert[0]].y;
  y2 = nodePos[tet->vert[1]].y;
  y3 = nodePos[tet->vert[2]].y;
  y4 = nodePos[tet->vert[3]].y;
  z1 = nodePos[tet->vert[0]].z;
  z2 = nodePos[tet->vert[1]].z;
  z3 = nodePos[tet->vert[2]].z;
  z4 = nodePos[tet->vert[3]].z;
  
  /* Calculate and check volume not 0.0 */

  vol = fabs(DET_3X3(x2,y2,z2, x3,y3,z3, x4,y4,z4)
    -DET_3X3(x1,y1,z1, x3,y3,z3, x4,y4,z4)
    +DET_3X3(x1,y1,z1, x2,y2,z2, x4,y4,z4)
    -DET_3X3(x1,y1,z1, x2,y2,z2, x3,y3,z3));
  
  if (vol > ALE_zero_tol) {
    m    = 3;
    n    = 3;
    nrhs = 1;

   /* Note that the A matrix is transposed to deal with the
    * FORTRAN column - wise storage used in BLAS */ 
   
   A[0] = x2 - x1; A[3] = y2 - y1; A[6] = z2 - z1;
   A[1] = x3 - x1; A[4] = y3 - y1; A[7] = z3 - z1;
   A[2] = x4 - x1; A[5] = y4 - y1; A[8] = z4 - z1;    
   sq   = x1*x1 + y1*y1 + z1*z1;
   b[0] = 0.5*(x2*x2 + y2*y2 + z2*z2 - sq);
   b[1] = 0.5*(x3*x3 + y3*y3 + z3*z3 - sq);
   b[2] = 0.5*(x4*x4 + y4*y4 + z4*z4 - sq);

   /* Solve system using BLAS */
   
   DGETRF(&m,&n,A,&m,ipiv,&info);
   if(info != 0) {
     printf("Error in DGETRF, Get_Circumdata3D: \n");
     if(info < 0) printf("%2dth argument had an error\n",info);
     else if(info > 0) printf("U(%2d,%2d) is exactly zero\n",info,info);
     exit(0);
   }

   DGETRS(trans,&n,&nrhs,A,&m,ipiv,b,&m,&info);
   if(info != 0) {
     printf("Error in DGETRS, Get_Circumdata3D: \n");
     if(info < 0) printf("%2dth argument had an error\n",info);
     exit(0);
   }
   
   dx       = b[0] - x1;
   dy       = b[1] - y1;
   dz       = b[2] - z1;
   tet->x   = b[0];
   tet->y   = b[1];
   tet->z   = b[2];
   tet->rsq = dx*dx+dy*dy+dz*dz;
 }
 else {
   tet->x   = 0.25*(x1 + x2 + x3 + x4);
   tet->y   = 0.25*(y1 + y2 + y3 + y4);
   tet->z   = 0.25*(z1 + z2 + z3 + z4);
   tet->rsq = 0.0;
 }
}

static int FoundOrder3Edge(TET_TYPE *tet,int ineib,TET_TYPE **teta,
                           TET_TYPE **tetb,TET_TYPE **tetc,
                           int *axisa,int *axisb)
{
  TET_TYPE *neib1,*neib2;
  int OK;
  
  neib1 = tet->nbor[ineib];
  if (neib1 == NULL) return (FALSE);
  
  OK = 10;
  neib2 = tet->nbor[(ineib + 1)%4];
  if (neib2) {
    if (neib2->nbor[0] == neib1) OK = 0; 
    else
    if (neib2->nbor[1] == neib1) OK = 1; 
    else
    if (neib2->nbor[2] == neib1) OK = 2; 
    else
	  if (neib2->nbor[3] == neib1) OK = 3;
    if (OK < 10) {
      *teta  = tet;
      *tetb  = neib1;
      *tetc  = neib2;
      *axisa = tet->vert[(ineib + 2)%4];
      *axisb = tet->vert[(ineib + 3)%4];
      return TRUE;
    }
  }
  
  neib2 = tet->nbor[(ineib + 2)%4];
  if (neib2) {
    if (neib2->nbor[0] == neib1) OK = 0; 
    else
    if (neib2->nbor[1] == neib1) OK = 1; 
    else
    if (neib2->nbor[2] == neib1) OK = 2; 
    else
	  if (neib2->nbor[3] == neib1) OK = 3;
    if (OK < 10) {
      *teta  = tet;
      *tetb  = neib1;
      *tetc  = neib2;
      *axisa = tet->vert[(ineib+1)%4];
      *axisb = tet->vert[(ineib+3)%4];
      return TRUE;
    }
  }
  
  neib2 = tet->nbor[(ineib + 3)%4];
  if (neib2) {
    if (neib2->nbor[0] == neib1) OK = 0; 
    else
    if (neib2->nbor[1] == neib1) OK = 1; 
    else
	  if (neib2->nbor[2] == neib1) OK = 2; 
	  else
    if (neib2->nbor[3] == neib1) OK = 3;
    if (OK < 10) {
      *teta  = tet;
      *tetb  = neib1;
      *tetc  = neib2;
      *axisa = tet->vert[(ineib + 2)%4];
      *axisb = tet->vert[(ineib + 1)%4];
      return TRUE;
    }
  }
  return FALSE;
}

static int FaceIsDelaunay(TET_TYPE *tet,int ineib)
{
  TET_TYPE *neib;
  int i;
  double dx,dy,dz;
  
  neib = tet->nbor[ineib];
  i    = tet->vert[ineib];
  
  dx = neib->x - nodePos[i].x;
  dy = neib->y - nodePos[i].y;
  dz = neib->z - nodePos[i].z;
  if ((neib->rsq - SMALL) > (dx*dx + dy*dy + dz*dz)) return FALSE;
  else return TRUE;
}


static int AssemblyIsConvex(TET_TYPE *tet,int ineib)
{
  TET_TYPE *neib;
  Pvector a,b,c,d,e;
  double f1,f2,f3;
  
  a = nodePos[tet->vert[ineib]];
  b = nodePos[tet->vert[(ineib + 1)%4]];
  c = nodePos[tet->vert[(ineib + 2)%4]];
  d = nodePos[tet->vert[(ineib + 3)%4]];
  
  neib = tet->nbor[ineib];
  if (neib->nbor[0] == tet)      e = nodePos[neib->vert[0]];
  else if (neib->nbor[1] == tet) e = nodePos[neib->vert[1]];
  else if (neib->nbor[2] == tet) e = nodePos[neib->vert[2]];
  else if (neib->nbor[3] == tet) e = nodePos[neib->vert[3]];
  
  b.x -= a.x;	b.y -= a.y;	b.z -= a.z;
  c.x -= a.x;	c.y -= a.y;	c.z -= a.z;
  d.x -= a.x;	d.y -= a.y;	d.z -= a.z;
  e.x -= a.x;	e.y -= a.y;	e.z -= a.z;
  
  f1 = TSP(e,c,b);
  
  if (f1 > 0.0) {
    f2 = TSP(e,d,c);
    if (f2 <= 0.0) return FALSE;
    f3 = TSP(e,b,d);
    if (f3 <= 0.0) return FALSE;
    return TRUE;
  }
  else {
    f2 = TSP(e,d,c);
    if (f2 >= 0.0) return FALSE;
    f3 = TSP(e,b,d);
    if (f3 >= 0.0) return FALSE;
    return TRUE;
  } 
}

static void FlipFaceToEdge(TET_TYPE *tet,int ineib,int *err_Flag,char *err_StringC)
{
  TET_TYPE *neib,*teta,*tetb,*tetc,*tneib;
  int a,b,c,d,e,jb,jc,jd,jneib,temp;
  
  teta = Create_Tet(err_Flag,err_StringC);
  if(*err_Flag != 0) {
    strcpy(err_StringC,">FlipFaceToEdge");
    return;
  }
  tetb = Create_Tet(err_Flag,err_StringC);
  if(*err_Flag != 0) {
    strcpy(err_StringC,">FlipFaceToEdge");
    return;
  }
  tetc = Create_Tet(err_Flag,err_StringC);
  if(*err_Flag != 0) {
    strcpy(err_StringC,">FlipFaceToEdge");
    return;
  }
  
  a    = tet->vert[ineib];
  b    = tet->vert[(ineib + 1)%4];
  c    = tet->vert[(ineib + 2)%4];
  d    = tet->vert[(ineib + 3)%4];
  
  neib = tet->nbor[ineib];
  
  if (neib->nbor[0] == tet) jneib = 0;
  else 
  if (neib->nbor[1] == tet) jneib = 1;
  else 
  if (neib->nbor[2] == tet) jneib = 2;
  else 
  if (neib->nbor[3] == tet) jneib = 3;
  
  e = neib->vert[jneib];
  
  temp = neib->vert[(jneib + 1)%4];
  
  if (temp == b) jb = (jneib + 1)%4; 
  else
  if (temp == c) jc = (jneib + 1)%4; 
  else
  if (temp == d) jd = (jneib + 1)%4;
  
  temp = neib->vert[(jneib + 2)%4];
  
  if (temp == b) jb = (jneib + 2)%4; 
  else
  if (temp == c) jc = (jneib + 2)%4; 
  else
  if (temp == d) jd = (jneib + 2)%4;
  
  temp = neib->vert[(jneib + 3)%4];
  
  if (temp == b) jb = (jneib + 3)%4; 
  else
  if (temp == c) jc = (jneib + 3)%4; 
  else
  if (temp == d) jd = (jneib + 3)%4;
  
  teta->vert[0] = a; 
  teta->nbor[0] = neib->nbor[jd];
  teta->vert[1] = e; 
  teta->nbor[1] = tet->nbor[(ineib + 3)%4];
  teta->vert[2] = b; 
  teta->nbor[2] = tetb;
  teta->vert[3] = c; 
  teta->nbor[3] = tetc;
  
  tetb->vert[0] = a; 
  tetb->nbor[0] = neib->nbor[jb];
  tetb->vert[1] = e; 
  tetb->nbor[1] = tet->nbor[(ineib+1)%4];
  tetb->vert[2] = c; 
  tetb->nbor[2] = tetc;
  tetb->vert[3] = d; 
  tetb->nbor[3] = teta;

  tetc->vert[0] = a; 
  tetc->nbor[0] = neib->nbor[jc];
  tetc->vert[1] = e; 
  tetc->nbor[1] = tet->nbor[(ineib+2)%4];
  tetc->vert[2] = d; 
  tetc->nbor[2] = teta;
  tetc->vert[3] = b; 
  tetc->nbor[3] = tetb;

  /* Do neighbours' neighbours */

  if (tneib = teta->nbor[0]) {
    if (tneib->nbor[0] == neib) tneib->nbor[0] = teta;
    else
    if (tneib->nbor[1] == neib) tneib->nbor[1] = teta;
    else
    if (tneib->nbor[2] == neib) tneib->nbor[2] = teta;
    else
    if (tneib->nbor[3] == neib) tneib->nbor[3] = teta;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }

  if (tneib = teta->nbor[1]) {
    if (tneib->nbor[0] == tet) tneib->nbor[0] = teta;
    else
    if (tneib->nbor[1] == tet) tneib->nbor[1] = teta;
    else
    if (tneib->nbor[2] == tet) tneib->nbor[2] = teta;
    else
    if (tneib->nbor[3] == tet) tneib->nbor[3] = teta;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }
  
  if (tneib = tetb->nbor[0]) {
    if (tneib->nbor[0] == neib) tneib->nbor[0] = tetb;
    else
    if (tneib->nbor[1] == neib) tneib->nbor[1] = tetb;
    else
    if (tneib->nbor[2] == neib) tneib->nbor[2] = tetb;
    else
    if (tneib->nbor[3] == neib) tneib->nbor[3] = tetb;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }
  if (tneib=tetb->nbor[1]) {
    if (tneib->nbor[0] == tet) tneib->nbor[0] = tetb;
    else
    if (tneib->nbor[1] == tet) tneib->nbor[1] = tetb;
    else
    if (tneib->nbor[2] == tet) tneib->nbor[2] = tetb;
    else
    if (tneib->nbor[3] == tet) tneib->nbor[3] = tetb;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }
  
  if (tneib = tetc->nbor[0]) {
    if (tneib->nbor[0] == neib) tneib->nbor[0] = tetc;
    else
    if (tneib->nbor[1] == neib) tneib->nbor[1] = tetc;
    else
    if (tneib->nbor[2] == neib) tneib->nbor[2] = tetc;
    else
    if (tneib->nbor[3] == neib) tneib->nbor[3] = tetc;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }
  if (tneib = tetc->nbor[1]) {
    if (tneib->nbor[0] == tet) tneib->nbor[0] = tetc;
    else
    if (tneib->nbor[1] == tet) tneib->nbor[1] = tetc;
    else
    if (tneib->nbor[2] == tet) tneib->nbor[2] = tetc;
    else
    if (tneib->nbor[3] == tet) tneib->nbor[3] = tetc;
    else {
      *err_Flag = 1;
      strcpy(err_StringC,">>Neighbour consistency error");
      return;
    }
  }	
  
	
  if (tet == flip3_next_tet) flip3_next_tet = tet->next;
  
  Delete_Tet(tet);
  
  if (neib==flip3_next_tet) flip3_next_tet = neib->next;
  
  Delete_Tet(neib);
  
  Add_Tet(teta);
  Add_Tet(tetb);
  Add_Tet(tetc);
  Get_Circumdata3D(teta);
  Get_Circumdata3D(tetb);
  Get_Circumdata3D(tetc);  
  
}

static void FlipEdgeToFace(TET_TYPE *teta,TET_TYPE *tetb, TET_TYPE *tetc,
                           int axisa, int axisb, int *err_Flag,
                           char *err_StringC)
{
  /* Takes as input pointers to 3 tetrahedra, and the 2 "axis" nodes 
   * Tets a,b,c -> tets A,B
   * 
   * The procedure:
   * a)   determines the 3 periphery nodes,
   * b)   stores the face_neighbours data structure,
   * c)   removes the three tets from the triangulation,
   * d)   Adds 2 New tets (A and B)and do circumdata,
   * e)   uses face_neighbours data to restore neighbour integrity
   */

  typedef struct {
    TET_TYPE *neib;  	/* pointer to neighbour tet */
    TET_TYPE **nptr; 	/* pointer to neighbour's back pointer */
  } face_neib_struct;
  
  TET_TYPE         *tetA,*tetB,*neib;
  face_neib_struct face_neib_A[3],face_neib_B[3];
  int              nper,itemp,per[4],opp_a,opp_b,opp_c;	/* periphery nodes */
  
  /* a) Determine the periphery nodes 
   *    Examine two tets, getting 4 non-axial nodes,
   *    of which two are duplicate */
  
  nper  = 0;
  itemp = teta->vert[0];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = teta->vert[1];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = teta->vert[2];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = teta->vert[3];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = tetb->vert[0];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = tetb->vert[1];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = tetb->vert[2];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  itemp = tetb->vert[3];
  if((itemp != axisa)&&(itemp != axisb)) {
    per[nper] = itemp;
    nper++;
  }
  
  if(nper != 4) {
   *err_Flag = 1;
    strcpy(err_StringC,">>4 periphery nodes not found");
    return;
  }
    
  /* If 1st node of tetb was in teta, use second node instead */
  
  if ((per[0] == per[2])||(per[1] == per[2])) per[2] = per[3];
  
  /* we know per[2] is opposite a, need to establish which of per0 and per1
   * are opposite b and c */
  
  opp_a = per[2];
  itemp = per[0];
  if ((tetb->vert[0] != itemp)&&(tetb->vert[1] != itemp)&&
      (tetb->vert[2] != itemp)&&(tetb->vert[3] != itemp)) {
    opp_b = itemp;
    opp_c = per[1];
  }
  else {
    opp_b = per[1];
    opp_c = itemp;
  }
  
  /* b) Store the face_neighbour data structure */
  
  /* teta */
  
  if      (axisa == teta->vert[0]) neib = teta->nbor[0];
  else if (axisa == teta->vert[1]) neib = teta->nbor[1];
  else if (axisa == teta->vert[2]) neib = teta->nbor[2];
  else if (axisa == teta->vert[3]) neib = teta->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis a not found in Tet a");
    return;
  }
  
  face_neib_B[0].neib=neib;

  if      (neib == NULL)     face_neib_B[0].nptr=NULL;
  else if (neib->nbor[0] == teta) face_neib_B[0].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == teta) face_neib_B[0].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == teta) face_neib_B[0].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == teta) face_neib_B[0].nptr = &(neib->nbor[3]);
  else {
    *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;
  }
  if      (axisb == teta->vert[0]) neib = teta->nbor[0];
  else if (axisb == teta->vert[1]) neib = teta->nbor[1];
	else if (axisb == teta->vert[2]) neib = teta->nbor[2];
  else if (axisb == teta->vert[3]) neib = teta->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis a not found in Tet a");
    return;    
  }
  
  face_neib_A[0].neib=neib;
  
  if      (neib == NULL)     face_neib_A[0].nptr = NULL;
  else if (neib->nbor[0] == teta) face_neib_A[0].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == teta) face_neib_A[0].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == teta) face_neib_A[0].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == teta) face_neib_A[0].nptr = &(neib->nbor[3]);
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;    
  }
  
  /* tetb */
  
  if      (axisa == tetb->vert[0]) neib = tetb->nbor[0];
  else if (axisa == tetb->vert[1]) neib = tetb->nbor[1];
  else if (axisa == tetb->vert[2]) neib = tetb->nbor[2];
  else if (axisa == tetb->vert[3]) neib = tetb->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis a not found in Tet b");
    return;    
  }
  
  face_neib_B[1].neib=neib;
  
  if      (neib == NULL)     face_neib_B[1].nptr = NULL;
  else if (neib->nbor[0] == tetb) face_neib_B[1].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == tetb) face_neib_B[1].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == tetb) face_neib_B[1].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == tetb) face_neib_B[1].nptr = &(neib->nbor[3]);
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;    
  }
  
  if      (axisb == tetb->vert[0]) neib = tetb->nbor[0];
  else if (axisb == tetb->vert[1]) neib = tetb->nbor[1];
  else if (axisb == tetb->vert[2]) neib = tetb->nbor[2];
  else if (axisb == tetb->vert[3]) neib = tetb->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis b not found in Tet b");
    return;    
  }
  
  face_neib_A[1].neib = neib;
  if      (neib == NULL)     face_neib_A[1].nptr = NULL;
  else if (neib->nbor[0] == tetb) face_neib_A[1].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == tetb) face_neib_A[1].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == tetb) face_neib_A[1].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == tetb) face_neib_A[1].nptr = &(neib->nbor[3]);
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;    
  }

  /* tetc */
  
  if      (axisa == tetc->vert[0]) neib = tetc->nbor[0];
  else if (axisa == tetc->vert[1]) neib = tetc->nbor[1];
  else if (axisa == tetc->vert[2]) neib = tetc->nbor[2];
  else if (axisa == tetc->vert[3]) neib = tetc->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis a not found in Tet c");
    return;    
  }
  
  face_neib_B[2].neib = neib;
  
  if      (neib == NULL)     face_neib_B[2].nptr = NULL;
  else if (neib->nbor[0] == tetc) face_neib_B[2].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == tetc) face_neib_B[2].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == tetc) face_neib_B[2].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == tetc) face_neib_B[2].nptr = &(neib->nbor[3]);
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;    
  }
  
  if      (axisb == tetc->vert[0]) neib = tetc->nbor[0];
  else if (axisb == tetc->vert[1]) neib = tetc->nbor[1];
  else if (axisb == tetc->vert[2]) neib = tetc->nbor[2];
  else if (axisb == tetc->vert[3]) neib = tetc->nbor[3];
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Axis b not found in Tet c");
    return;    
  }
  
  face_neib_A[2].neib = neib;
  
  if      (neib == NULL)     face_neib_A[2].nptr = NULL;
  else if (neib->nbor[0] == tetc) face_neib_A[2].nptr = &(neib->nbor[0]);
  else if (neib->nbor[1] == tetc) face_neib_A[2].nptr = &(neib->nbor[1]);
  else if (neib->nbor[2] == tetc) face_neib_A[2].nptr = &(neib->nbor[2]);
  else if (neib->nbor[3] == tetc) face_neib_A[2].nptr = &(neib->nbor[3]);
  else {
   *err_Flag = 1;
    strcpy(err_StringC,">>Neighbour inconsistency");
    return;    
  }
  
  /* c) delete teta,teb,tetc */
  
  if (teta == flip3_next_tet) flip3_next_tet = teta->next;
  Delete_Tet(teta);
  if (tetb == flip3_next_tet) flip3_next_tet = tetb->next;
  Delete_Tet(tetb);
  if (tetc == flip3_next_tet) flip3_next_tet = tetc->next;
  Delete_Tet(tetc);
  
  /* d) create new tets A and B */

  tetA = Create_Tet(err_Flag,err_StringC);
  if(*err_Flag != 0) {
    strcpy(err_StringC,">FlipEdgeToFace");
    return;
  }
  tetB = Create_Tet(err_Flag,err_StringC);
  if(*err_Flag != 0) {
    strcpy(err_StringC,">FlipEdgeToFace");
    return;
  }
  
  Add_Tet(tetA);
  Add_Tet(tetB);
  tetA->vert[0] = axisa;
  tetB->vert[0] = axisb;
  tetA->vert[1] = opp_a;
  tetB->vert[1] = opp_a;
  tetA->vert[2] = opp_b;
  tetB->vert[2] = opp_b;
  tetA->vert[3] = opp_c;
  tetB->vert[3] = opp_c;
  tetA->nbor[0] = tetB;
  tetB->nbor[0] = tetA;
  Get_Circumdata3D(tetA);
  Get_Circumdata3D(tetB);
  
  /* e) Update other neighbours */

  tetA->nbor[1] = face_neib_A[0].neib;
  if (face_neib_A[0].nptr) *(face_neib_A[0].nptr) = tetA;
  tetA->nbor[2] = face_neib_A[1].neib;
  if (face_neib_A[1].nptr) *(face_neib_A[1].nptr) = tetA;
  tetA->nbor[3] = face_neib_A[2].neib;
  if (face_neib_A[2].nptr) *(face_neib_A[2].nptr) = tetA;
  
  tetB->nbor[1] = face_neib_B[0].neib;
  if (face_neib_B[0].nptr) *(face_neib_B[0].nptr) = tetB;
  tetB->nbor[2] = face_neib_B[1].neib;
  if (face_neib_B[1].nptr) *(face_neib_B[1].nptr) = tetB;
  tetB->nbor[3] = face_neib_B[2].neib;
  if (face_neib_B[2].nptr) *(face_neib_B[2].nptr) = tetB;
}

static void flip3(int *ntet,int *err_Flag,char *err_StringC)
{
  /* Repeatedly flips the triangulation until it becomes Delaunay. */
  
  TET_TYPE *tet,*teta,*tetb,*tetc;
  int axisa,axisb,ineib,Delaunay,Flips,totalflips,passes,list_passes;
  
  /* If not Delaunay and flips==0 at end of tet loop, then Houston, we
   * appear to have a problem- probably a convexity hiccup */
  
  
  totalflips=passes=0;
  do {
    Delaunay = TRUE;
    Flips = 0;  
    list_passes = 0;
    flip3_next_tet = tet_head; 
    while (flip3_next_tet) {
      list_passes++;
      tet = flip3_next_tet;
      flip3_next_tet = tet->next;     		
      for (ineib = 0;ineib < 4;ineib++) {
        if (tet->nbor[ineib] != NULL) {
          if (!FaceIsDelaunay(tet,ineib)) {
            Delaunay = FALSE;
            if(FoundOrder3Edge(tet,ineib,&teta,&tetb,&tetc,&axisa,&axisb)) {
              FlipEdgeToFace(teta,tetb,tetc,axisa,axisb,err_Flag,err_StringC);
              if(*err_Flag != 0) {
                strcpy(err_StringC,">FlipEdgeToFace");
                return;
              }
              (*ntet)--;
              Flips++;
              break; /* leave local tet face loop */
            }	
            else if(AssemblyIsConvex(tet,ineib)) {
              FlipFaceToEdge(tet,ineib,err_Flag,err_StringC);
              if(*err_Flag != 0) {
                strcpy(err_StringC,">FlipFaceToEdge");
                return;
              }
              (*ntet)++;
              Flips++;
              break; /* leave local tet face loop */
            }
          }
        } 
      }
    }
    passes++;
    totalflips+=Flips;
    printf(" Pass = %2d\n",passes);
    printf(" Number of flips performed = %5d\n",Flips);
    printf(" Number of elements scanned = %6d\n",list_passes);
    printf(" Cumulative flips = %5d\n\n",totalflips);
  } while (!(Delaunay||(Flips == 0)));
  if(!(Delaunay) && (Flips == 0)) {
    printf(">Non Delaunay - non flippability\n");
    return;
  }
}

extern void ALE_initialise(
  int *NAM,
  int *nb,
  int *NBFM,
  int *NCM,
  int *NELIST,
  int *NEM,
  int *NEELEM,
  int  NEIM,
  int *NHM,
  int *NIM,
  int *NJM,
  int *NKM,
  int *NNM,
  int *NPLIST,
  int *NPM,
  int *NPNE,
  int *NPNODE,
  int *NVJE,
  int *NVM,
  int *NXI,
  double *XP,
  double *ZA,
  double *zero_tol,
  int *err_Flag,
  char *err_StringC
  )
{
/* Note the size of each of the CMISS arrays:
 * 
 * NPNE( NNM    , NBFM, NEM       )
 * NVJE( NNM    , NBFM, NJM  , NEM)
 * NXI (-NIM:NIM, 0:NEIM, 0:NEM   )
 * XP  ( NKM    , NVM , NJM  , NPM)
 * ZA  ( NAM    , NHM , NCM  , NEM)
 *
 */

  int        ne,nbor1;
  int        np,node,nonode,noelem;
  short      nn;
  TET_TYPE **tetindx,*tet;
  int        jump_NNM,jump_NNM_NBFM;
  int        jump_NXI_0,jump_NXI_nn,jump_NXI_ne;

  /* Firstly destroy any ALE data structure that currently exists */
  if(tet_head != NULL) DestroyTetList();
  if(nodePos != NULL) free(nodePos);
  
  /* Allocate memory for nodal positions, tet indexing */

  if(!(nodePos = (Pvector *) malloc((NPNODE[0])*sizeof(Pvector)))) {
    *err_Flag = 1;
    strcpy(err_StringC,"Malloc fails for nodePos>ALE_initialise");
    return;
  }
  if(!(tetindx = (TET_TYPE **) calloc((NEELEM[0]),sizeof(TET_TYPE *)))) {
    *err_Flag = 1;
    strcpy(err_StringC,"Malloc fails for tetindx>ALE_initialise");
    return;
  }

  ALE_zero_tol = *zero_tol;

  for(noelem = 1; noelem <= NEELEM[0]; noelem++) {
    ne = NEELEM[noelem];
    tet = Create_Tet(err_Flag,err_StringC);
    if(*err_Flag != 0) {
      strcpy(err_StringC,">ALE_initialise");
      return;
    }
    Add_Tet(tet);
    tetindx[noelem - 1] = tet;
  }
  
  jump_NNM          = (*NNM);
  jump_NNM_NBFM     = (*NNM)*(*NBFM);
  
  jump_NXI_nn       = *NIM * 2 + 1;
  jump_NXI_ne       = jump_NXI_nn * (1+NEIM);
  jump_NXI_0        = *NIM + jump_NXI_nn + jump_NXI_ne;

  /* Get nodal and elemental information from CMISS arrays */
  
  for(noelem = 1; noelem <= NEELEM[0]; noelem++) {
    ne  = NEELEM[noelem] - 1;
    tet = tetindx[noelem - 1];   
    for(nn = 0; nn < 4; nn++) {
      np = NPNE[jump_NNM_NBFM*ne + jump_NNM*(*nb - 1) + nn];
      nonode = NPLIST[np];
      node = nonode - 1;
      if(node >= NPNODE[0]) { 
	*err_Flag = 1;
	strcpy(err_StringC,"More nodes than malloced");
	return;
      }
      tet->vert[nn] = node;
      nbor1         = NXI[ jump_NXI_0 + jump_NXI_nn * nn + jump_NXI_ne * ne ];
      if(nbor1 != 0) tet->nbor[nn] = tetindx[NELIST[nbor1] - 1];
      else tet->nbor[nn] = NULL;
    }
  }
  free(tetindx);
  
}

extern void ALE_flip(
  int *NAM,
  int *nb,
  int *NBFM,
  int *NCM,
  int *NELIST,
  int *NEM,
  int *NEELEM,
  int  NEIM,
  int *NHM,
  int *NIM,
  int *NJM,
  int *NKM,
  int *NNM,
  int *NPLIST,
  int *NPM,
  int *NPNE,
  int *NPNODE,
  int *NVJE,
  int *NVM,
  int *NXI,
  double *XP,
  double *ZA,
  int *err_Flag,
  char *err_StringC
  )
{
/* Note the size of each of the CMISS arrays:
 * 
 * NPNE( NNM    , NBFM, NEM       )
 * NVJE( NNM    , NBFM, NJM  , NEM)
 * NXI (-NIM:NIM, 0:NEIM, 0:NEM   )
 * XP  ( NKM    , NVM , NJM  , NPM)
 * ZA  ( NAM    , NHM , NCM  , NEM)
 *
 */

  int       ne;
  int       np,node,noelem,nonode,ntet;
  short     nn;
  TET_TYPE *tet;
  int       jump_NNM,jump_NNM_NBFM,jump_NKM_NVM;
  int       jump_NKM_NVMx2,jump_NKM_NVM_NJM;
  int       jump_NAM,jump_NAMx2,jump_NAMx3;
  int       jump_NAM_NHM_NCM;
  int        jump_NXI_0,jump_NXI_nn,jump_NXI_ne;
  int       *this_NXI;
  
  jump_NNM          = (*NNM);
  jump_NNM_NBFM     = (*NNM)*(*NBFM);
  jump_NKM_NVM      = (*NKM)*(*NVM);
  jump_NKM_NVMx2    = jump_NKM_NVM*2;
  jump_NKM_NVM_NJM  = jump_NKM_NVM*(*NJM);
  jump_NAM          = (*NAM);
  jump_NAMx2        = (*NAM)*2;
  jump_NAMx3        = jump_NAMx2 + (*NAM);
  jump_NAM_NHM_NCM  = jump_NAM*(*NHM)*(*NCM);

  jump_NXI_nn       = *NIM * 2 + 1;
  jump_NXI_ne       = jump_NXI_nn * (1+NEIM);
  jump_NXI_0        = *NIM + jump_NXI_nn + jump_NXI_ne;

  /* Transfer the nodal information from CMISS */
  for(nonode = 1; nonode <= NPNODE[0]; nonode++) {
    np = NPNODE[nonode] - 1;
    node = nonode - 1;
    if(node != (NPLIST[np + 1] - 1)) { 
      *err_Flag = 1;
      strcpy(err_StringC,"Node number does not match NPLIST number");
      return;
    }

    /* Nodal Information */
    nodePos[node].x = XP[jump_NKM_NVM_NJM*np];
    nodePos[node].y = XP[jump_NKM_NVM_NJM*np + jump_NKM_NVM];
    nodePos[node].z = XP[jump_NKM_NVM_NJM*np + jump_NKM_NVMx2];
  }


  noelem = 1;
  for(tet = tet_head;tet != NULL;tet = tet->next) {
    ne  = NEELEM[noelem] - 1;

   /* Circumcentre information */    
    tet->x   = ZA[jump_NAM_NHM_NCM*ne];
    tet->y   = ZA[jump_NAM_NHM_NCM*ne + jump_NAM];
    tet->z   = ZA[jump_NAM_NHM_NCM*ne + jump_NAMx2];
    tet->rsq = ZA[jump_NAM_NHM_NCM*ne + jump_NAMx3];

    noelem++;
  }
  ntet = noelem - 1;

  flip3(&ntet,err_Flag,err_StringC);
  NEELEM[0] = ntet;
  
  if(*err_Flag != 0) {
    strcpy(err_StringC,">flip3>ALE_flip");
    return;
  }
  
  /* Mesh has now been flipped and is Delaunay, so we can
   * now transfer from Were data structures to CMISS ones. */
  
  ne = NEELEM[1];
  noelem = 1;
  for(tet = tet_head;tet != NULL;tet = tet->next) {
    tet->indx  = noelem - 1;
    NEELEM[noelem] = ne;
    noelem++;
    ne++;
  }

  noelem = 1;
  for(tet = tet_head;tet != NULL;tet = tet->next) {
    ne = NEELEM[noelem] - 1;
    for(nn = 0;nn < 4;nn++) {
      node = NPNODE[tet->vert[nn] + 1];
      NPNE[jump_NNM_NBFM*ne + jump_NNM*(*nb - 1) + nn] = node;
      this_NXI = NXI + jump_NXI_0 + jump_NXI_nn * nn + jump_NXI_ne * ne;
      if(tet->nbor[nn] == NULL) {
        *this_NXI = 0;
      }
      else {
        *this_NXI = NEELEM[tet->nbor[nn]->indx + 1];
      }
    }
    ZA[jump_NAM_NHM_NCM*ne]              = tet->x;
    ZA[jump_NAM_NHM_NCM*ne + jump_NAM]   = tet->y;  
    ZA[jump_NAM_NHM_NCM*ne + jump_NAMx2] = tet->z;  
    ZA[jump_NAM_NHM_NCM*ne + jump_NAMx3] = tet->rsq;
    noelem++;
  }
}

extern void ALE_destroy()
{
  free(nodePos);
  DestroyTetList();  
}

