      SUBROUTINE IOSIGN(FILEID,LD,NBJ,NDDATA,NUMTIMEDATA,ZD_OFFSET,
     '  SIGNALMAX,SIGNALMIN,TIME,WD,XID,ZD,COMMAND,FILEFORMAT,FILENAME,
     '  SUBCOMMAND,ENDFILE,NEXTTIME,ERROR,*)

CC AJPs
C#### Subroutine: IOSIGN
C###  Description:
C###    IOSIGN reads and writes .ipsign or .binsig files. COMMAND
C###    determines whether data is to be read from ('READ') or
C###    written to ('WRITE') FILEID FILEFORMAT indicates whether or
C###    not the file is an 'ASCII' or a 'BINARY' file.
CC AJPe

C#### Comment: BINARY SIGNAL FILE FORMAT
C###  Description:
C###    <HTML>
C###    Signal data consists of a collection of the values of electrodes
C###    at certain points in time. For signal data there are three tags.
C###    <P>
C###    TAG INDEX = 1 : Signal generation information.
C###    </P>
C###    <UL>
C###    <LI>An integer to indicate the number of bytes in the signal
C###        generation description.
C###    <LI>A sequence of (number of description bytes) characters for
C###        the description of the signal generation.
C###    <LI>An integer to indicate how the signal was generated.
C###        Currently the values are 0 - generated (calculated)
C###        internally by CMISS, 1 - converted from an EMAP .signal
C###        file.
C###    <LI>If the file was generated by CMISS then
C###        <UL>
C###        <LI>No further information currently included.
C###        </UL>
C###        If the file was converted from EMAP then
C###        <UL>
C###        <LI>An integer to indicate the number of regions in the file
C###        <LI>(number of regions+1) integers to indicate the types of
C###            rig. The first rig type is the global (region 0) rig
C###            type (see emap00.cmn for rig types).
C###        <LI>An integer to indicate the number of bytes in the rig
C###            description.
C###        <LI>A sequence of (number of description bytes) characters
C###            for the rig description.
C###        <LI>A double precision number to indicate the sampling
C###            frequency.
C###        </UL>
C###    </UL>
C###    TAG INDEX = 2 : Electrode data
C###    <UL>
C###    <LI>An integer to indicate how many regions of electrodes
C###        are contained in the file.
C###    <LI>For each electrode region
C###        <UL>
C###        <LI>An integer to indicate the number of description bytes
C###            for the region description.
C###        <LI>A sequence of (number of description bytes) characters
C###            for the description of each region.
C###        <LI>An integer to indicate the  number of electrodes in the
C###            region.
C###        <LI>A sequence of (number of electrode) integers to
C###            uniquely indentify each electrode.
C###        <LI>An integer to indicate the type of region. Currently
C###            the region types are: 0 - irregular rectangular
C###            cartesian region (and others in the future)
C###        <LI>If the region type is irregular rectangular cartesian
C###            then
C###            <UL>
C###            <LI>An integer indicating the number of geometric
C###                dimensions.
C###            <LI>A seqence of single precision numbers indicating
C###                the geometric coordinates of the electrode. The
C###                values are stored as the set of geometric
C###                coordinates for each electrode in the region.
C###            <LI>A seqence of single precision numbers indicating
C###                the weight associated with the geometric
C###                coordinates of the electrode. The values are stored
C###                as the set of weights for each geometric coordinate
C###                for each electrode in the region.
C###            <LI>A sequence of (number of electrode) single precision
C###                numbers indicating the weight associated with the
C###                signal data for each electrode. For example if the
C###                electrode is good the weight might be 1.00 and if
C###                the electrode is bad the weight might be 0.00.
C###            </UL>
C###        <LI>An integer to indicate whether the electrode element
C###            locations are (=1) stored or are not (=0) stored.
C###        <LI>If the electrode element locations are stored then:
C###            <UL>
C###            <LI>A sequence of (number of electrode) integers
C###                indicating the element that each electrode is
C###                located in. If the electrode is not located in
C###                any element then the element is zero.
C###            <LI>An integer indicating the number of xi coordinates
C###                used to locate the electrode.
C###            <LI>A sequence of single precision numbers indicating
C###                the xi locations of the electrode in the element.
C###                The values are stored as the set of xi locations
C###                for each element in the region.
C###            </UL>
C###        </UL>
C###    </UL>
C###    TAG INDEX = 3 : Signal data
C###    <UL>
C###    <LI>A double precision number for the time at which the
C###        electrode data was obtained.
C###    <LI>For each region a sequence of single precision numbers
C###        indicating the value of each electrode in the region at
C###        the time indicated.
C###    </UL>
C###    Note: The number of times stored is given by the number of tags
C###    minus 2.
C###    </HTML>

      IMPLICIT NONE
      INCLUDE 'b00.cmn'
      INCLUDE 'b01.cmn'
      INCLUDE 'binf00.cmn'
      INCLUDE 'call00.cmn'
      INCLUDE 'cbdi02.cmn'
      INCLUDE 'data00.cmn'
      INCLUDE 'emap00.cmn'
      INCLUDE 'geom00.cmn'
      INCLUDE 'mach00.cmn'
      INCLUDE 'mach00.inc'
      INCLUDE 'sign00.cmn'
!     Parameter List
      INTEGER FILEID,LD(NDM),NBJ(NJM,NEM),NDDATA(0:NDM,0:NRM),
     '  NUMTIMEDATA,ZD_OFFSET
      REAL*8 SIGNALMAX(*),SIGNALMIN(*),TIME,WD(NJM,NDM),XID(NIM,NDM),
     '  ZD(NJM,NDM)
      CHARACTER COMMAND*(*),ERROR*(*),FILEFORMAT*(*),FILENAME*(*),
     '  SUBCOMMAND*(*)
      LOGICAL ENDFILE,NEXTTIME

!     Local Variables
      INTEGER CERROR(50),CERRLEN,EMAP_NUMREG(1),EMAP_NUMRB(1),
     '  ERR,FILETYPE,IBEG,IDUMMY,IEND,
     '  nb,nd,ndd,ni,nj,njjt,NJJT2(1),nodata,noelec,nr,NUMBTS(1),
     '  NUMBYTES,OLDIOTYPE,VERSION(3)
      REAL*4 DUMMY1(1),X(3)
      REAL*8 EMAP_FRQ(1),FILETIM(1),FILETIME,DUMMY,TIME2(1)
      LOGICAL FOUND,ISBINFILEOPEN,ISENDBINFILE
      CHARACTER LINE*132,FMT*500

!     Functions
      REAL*8 RFROMC
      
      CALL ENTERS('IOSIGN',*9999)
      NUMBYTES=0 !initialising

      IF(DOP) THEN
C KAT 14May01: Can't branch out of critical section.
C              Critical section is not essential.
CC$      call mp_setlock()
        WRITE(OP_STRING,'('' Command : '',A,'
     '    //'/'' Subcommand : '',A,'
     '    //'/'' Fileformat : '',A,'
     '    //'/'' Filename : '',A,'
     '    //'/'' FileID : '',I5)') COMMAND,SUBCOMMAND,FILEFORMAT,
     '    FILENAME,FILEID
        CALL WRITES(IODI,OP_STRING,ERROR,*9999)
CC$      call mp_unsetlock()
      ENDIF

      IF(COMMAND(1:4).EQ.'READ') THEN

        IF(FILEFORMAT(1:5).EQ.'ASCII') THEN

          IF(SUBCOMMAND(1:4).EQ.'OPEN') THEN

            OLDIOTYPE=IOTYPE
            IOTYPE=2 !Read
            VERSION(1)=1 !4/5/97
            CALL OPEN_SEQ_FILE(VERSION(1),FILEID,FILENAME,
     '        'sign','OLD',.FALSE.,ERROR,*9999)
            IOTYPE=OLDIOTYPE

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C            READ(FILEID,'('' Generation information : '',A)')
C     '        SIGNAL_HEADER(FILEID)
            FMT='('' Generation information : '',A)'
            READ(FILEID,FMT) SIGNAL_HEADER(FILEID)
            CALL STRING_TRIM(SIGNAL_HEADER(FILEID),IBEG,IEND)
            IF(IBEG.GT.IEND) THEN
              SIGNAL_HEADERBYTES(FILEID)=0
            ELSE IF(IBEG.EQ.IEND.AND.
     '          SIGNAL_HEADER(FILEID)(IBEG:IEND).EQ.' ') THEN
              SIGNAL_HEADERBYTES(FILEID)=0
            ELSE
              SIGNAL_HEADERBYTES(FILEID)=IEND-IBEG+1
            ENDIF
            READ(FILEID,'(A)') LINE
            READ(FILEID,'(A)') LINE
            IF(LINE(26:30).EQ.'CMISS') THEN
              SIGNAL_HOWGENERATED(FILEID)=0
            ELSE IF(LINE(26:31).EQ.'UnEmap') THEN
              SIGNAL_HOWGENERATED(FILEID)=1

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C              READ(FILEID,'('' Number of UnEmap regions: '',I2)')
C     '          EMAP_NUMREGIONS
C              READ(FILEID,'('' UnEmap rig types:'',10(1X,I2))')
C     '          (EMAP_RIGTYPE(nr),nr=0,EMAP_NUMREGIONS)
C              READ(FILEID,'('' UnEmap rig name: '',A)')
C     '          EMAP_RIGNAME

              FMT='('' Number of UnEmap regions: '',I2)'
              READ(FILEID,FMT) EMAP_NUMREGIONS
              FMT='('' UnEmap rig types:'',10(1X,I2))'
              READ(FILEID,FMT) (EMAP_RIGTYPE(nr),nr=0,EMAP_NUMREGIONS)
              FMT='('' UnEmap rig name: '',A)'
              READ(FILEID,FMT) EMAP_RIGNAME

              CALL STRING_TRIM(EMAP_RIGNAME,IBEG,IEND)
              IF(IBEG.GT.IEND) THEN
                EMAP_NUMRIGNAMEBYTES=0
              ELSE IF(IBEG.EQ.IEND.AND.
     '            EMAP_RIGNAME(IBEG:IEND).EQ.' ') THEN
                EMAP_NUMRIGNAMEBYTES=0
              ELSE
                EMAP_NUMRIGNAMEBYTES=IEND-IBEG+1
              ENDIF

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C              READ(FILEID,'('' UnEmap sampling frequency (Hz): '','
C     '          //'D12.5)') EMAP_FREQUENCY
              FMT='('' UnEmap sampling frequency (Hz): '',D12.5)'
              READ(FILEID,FMT) EMAP_FREQUENCY
            ELSE
              ERROR='>>Invalid file format'
              GOTO 9999
            ENDIF

          ELSE IF(SUBCOMMAND(1:5).EQ.'RESET') THEN

            CALL CLOSEF(FILEID,ERROR,*9999)
            OLDIOTYPE=IOTYPE
            IOTYPE=2 !Read
            VERSION(1)=1 !5/5/97
            CALL OPEN_SEQ_FILE(VERSION(1),FILEID,FILENAME,
     '        'sign','OLD',.FALSE.,ERROR,*9999)
            IOTYPE=OLDIOTYPE

            READ(FILEID,'(A)') LINE
            READ(FILEID,'(A)') LINE
            READ(FILEID,'(A)') LINE
            IF(LINE(26:30).EQ.'CMISS') THEN
            ELSE IF(LINE(26:31).EQ.'UnEmap') THEN
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
            ELSE
              ERROR='>>Invalid file format'
              GOTO 9999
            ENDIF
            READ(FILEID,'(A)') LINE
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE
C LCK 11-AUG-97 added and additional read line for :  Number of electr...
              READ(FILEID,'(A)') LINE
              IF(SIGNAL_NUMELEC(nr,FILEID).LE.10) THEN

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                READ(FILEID,'('' Electrode numbers:'',10(1X,I5))')
C     '            (IDUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                FMT='('' Electrode numbers:'',10(1X,I5))'
                READ(FILEID,FMT)
     '            (IDUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
              ELSE

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
                FMT='('' Electrode numbers:'',10(1X,I5),'
     '            //':/(19X,10(1X,I5)))'
                READ(FILEID,FMT) (IDUMMY,nodata=1,
     '            SIGNAL_NUMELEC(nr,FILEID))
              ENDIF
              READ(FILEID,'(A)') LINE
              IF(LINE(17:25).EQ.'irregular') THEN
                READ(FILEID,'(A)') LINE
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  READ(FILEID,'(A)') LINE
                ENDDO
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  READ(FILEID,'(A)') LINE
                ENDDO
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  READ(FILEID,'(A)') LINE
                ENDDO
                READ(FILEID,'(A)') LINE
                IF(LINE(24:26).EQ.'not') THEN
                ELSE IF(LINE(24:29).EQ.'stored') THEN
                  IF(SIGNAL_NUMELEC(nr,FILEID).LE.10) THEN
C LKC 12-AUG-97 Change write to read
C                    WRITE(FILEID,'
C('' Element numbers:'',10(1X,I5))')
C     '                (IDUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
C                  ELSE
C                    WRITE(FILEID,'('' Element numbers:'',10(1X,I5),'
C     '                //':/(17X,10(1X,I5)))') (IDUMMY,
C     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                    READ(FILEID,'('' Element numbers:'',10(1X,I5))')
C     '                (IDUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
C                  ELSE
C                    READ(FILEID,'('' Element numbers:'',10(1X,I5),'
C     '                //':/(17X,10(1X,I5)))') (IDUMMY,
C     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))

                    FMT='('' Element numbers:'',10(1X,I5))'
                    READ(FILEID,FMT)
     '                (IDUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                  ELSE
                    FMT='('' Element numbers:'',10(1X,I5),'
     '                //':/(17X,10(1X,I5)))'
                    READ(FILEID,FMT) (IDUMMY,
     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))

                  ENDIF
                  READ(FILEID,'(A)') LINE
                  READ(FILEID,'(A)') LINE
                  DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                    READ(FILEID,'(A)') LINE
                  ENDDO
                ELSE
                  ERROR='>>Invalid file format'
                  GOTO 9999
                ENDIF
              ELSE
                ERROR='>>Invalid file format'
                GOTO 9999
              ENDIF
            ENDDO !nr

          ELSE IF(SUBCOMMAND(1:11).EQ.'SIGNAL_DATA') THEN

            ENDFILE=.FALSE.

 10         READ(FILEID,'(A)',END=9998) LINE

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C            READ(FILEID,'('' Time = '',D11.4)') FILETIME

C LKC 6-NOV-2003 Need to increase the precision and seeing we can't
C           use an unformatted read we need to read into a string, then
C           convert to a REAL number
C            
C            FMT='('' Time = '',D11.4)'
C            READ(FILEID,FMT) FILETIME

            FMT='('' Time = '',A)'
            READ(FILEID,FMT) LINE
            FILETIME=RFROMC(LINE)

            IF(.NOT.NEXTTIME) THEN
              IF(FILETIME.LT.TIME) THEN
                READ(FILEID,'(A)') LINE
                DO nr=1,SIGNAL_NUMREGIONS(FILEID)
                  IF(SIGNAL_NUMELEC(nr,FILEID).LE.5) THEN

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                    READ(FILEID,'(1X,5(1X,E12.5))')
C     '                (DUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
C                  ELSE
C                    READ(FILEID,'(1X,5(1X,E12.5),:/(1X,5(1X,E12.5)))')
C     '                (DUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))

                    FMT='(1X,5(1X,E12.5))'
                    READ(FILEID,FMT)
     '                (DUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                  ELSE
                    FMT='(1X,5(1X,E12.5),:/(1X,5(1X,E12.5)))'
                    READ(FILEID,FMT)
     '                (DUMMY,nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                  ENDIF
                ENDDO
                GOTO 10
              ELSE
                TIME=FILETIME
              ENDIF
            ELSE
              TIME=FILETIME
            ENDIF
            READ(FILEID,'(A)') LINE
            CALL ASSERT(NJT+ZD_OFFSET+1.LE.NJM,'>>Increase NJMX',
     '        ERROR,*9999)
            IF(LINE(2:13).EQ.'Signal Data:') THEN
              DO nr=1,SIGNAL_NUMREGIONS(FILEID)
                IF(SIGNAL_NUMELEC(nr,FILEID).LE.5) THEN

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                  READ(FILEID,'(1X,5(1X,E12.5))')
C     '              (ZD(NJT+ZD_OFFSET+1,NDDATA(nodata,nr)),nodata=1,
C     '              SIGNAL_NUMELEC(nr,FILEID))
C                ELSE
C                  READ(FILEID,'(1X,5(1X,E12.5),:/(1X,5(1X,E12.5)))')
C     '              (ZD(NJT+ZD_OFFSET+1,NDDATA(nodata,nr)),nodata=1,
C     '              SIGNAL_NUMELEC(nr,FILEID))

                  FMT='(1X,5(1X,E12.5))'
                  READ(FILEID,FMT)
     '              (ZD(NJT+ZD_OFFSET+1,NDDATA(nodata,nr)),nodata=1,
     '              SIGNAL_NUMELEC(nr,FILEID))
                ELSE
                  FMT='(1X,5(1X,E12.5),:/(1X,5(1X,E12.5)))'
                  READ(FILEID,FMT)
     '              (ZD(NJT+ZD_OFFSET+1,NDDATA(nodata,nr)),nodata=1,
     '              SIGNAL_NUMELEC(nr,FILEID))

                ENDIF
              ENDDO
            ELSE
              ERROR='>>Invalid file format'
              GOTO 9999
            ENDIF

          ELSE IF(SUBCOMMAND(1:14).EQ.'ELECTRODE_DATA') THEN

            READ(FILEID,'(A)') LINE

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C            READ(FILEID,'('' Number of electrode regions: '',I2)')
C     '        SIGNAL_NUMREGIONS(FILEID)
            FMT='('' Number of electrode regions: '',I2)'
            READ(FILEID,FMT) SIGNAL_NUMREGIONS(FILEID)

            CALL ASSERT(SIGNAL_NUMREGIONS(FILEID).LE.NSIGNALREGIONSMX,
     '        '>>Increase NSIGNALREGIONSMX in sign00.cmn',ERROR,*9999)
            CALL ASSERT(SIGNAL_NUMREGIONS(FILEID).LE.NRM,
     '        '>>Increase NRMX',ERROR,*9999)
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              READ(FILEID,'(A)') LINE
              READ(FILEID,'(A)') LINE

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C              READ(FILEID,'('' Region description: '',A)')
C     '          SIGNAL_REGNAME(nr,FILEID)
              FMT='('' Region description: '',A)'
              READ(FILEID,FMT) SIGNAL_REGNAME(nr,FILEID)

              CALL STRING_TRIM(SIGNAL_REGNAME(nr,FILEID),IBEG,IEND)
C LKC 11-AUG-97 ->read      WRITE(FILEID,
C'('' Number of electrodes: '',I5)')
C     '          SIGNAL_NUMELEC(nr,FILEID)

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C              READ(FILEID,'('' Number of electrodes: '',I5)')
C     '          SIGNAL_NUMELEC(nr,FILEID)
              FMT='('' Number of electrodes: '',I5)'
              READ(FILEID,FMT) SIGNAL_NUMELEC(nr,FILEID)

              CALL ASSERT(USE_DATA.GT.0,'>>Set USE_DATA to 1',ERROR,
     '          *9999)
              CALL ASSERT(SIGNAL_NUMELEC(nr,FILEID).LE.NDM,
     '          '>>Increase NDM',ERROR,*9999)
              NDDATA(0,nr)=SIGNAL_NUMELEC(nr,FILEID)
              IF(SIGNAL_NUMELEC(nr,FILEID).LE.10) THEN

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                READ(FILEID,'('' Electrode numbers:'',10(1X,I5))')
C     '           (NDDATA(nodata,nr),nodata=1,SIGNAL_NUMELEC(nr,FILEID))
C              ELSE
C                READ(FILEID,'('' Electrode numbers:'',10(1X,I5),'
C     '            //':/(19X,10(1X,I5)))') (NDDATA(nodata,nr),nodata=1,
C     '            SIGNAL_NUMELEC(nr,FILEID))

                FMT='('' Electrode numbers:'',10(1X,I5))'
                READ(FILEID,FMT)
     '            (NDDATA(nodata,nr),nodata=1,SIGNAL_NUMELEC(nr,FILEID))
              ELSE
                FMT='('' Electrode numbers:'',10(1X,I5),'
     '            //':/(19X,10(1X,I5)))'
                READ(FILEID,FMT) (NDDATA(nodata,nr),nodata=1,
     '            SIGNAL_NUMELEC(nr,FILEID))

              ENDIF

C LKC 31-AUG-1999 does not work if non-sequential electrode numbers
C
C              DO nodata=1,NDDATA(0,nr)
C                nd=NDDATA(nodata,nr)
C                IF(nd.GT.NDT) NDT=nd
C              ENDDO !nodata (nd)
              NDT=NDDATA(0,nr)

              CALL ASSERT(NDT.LE.NDM,'>>Increase NDM',ERROR,*9999)
              READ(FILEID,'(A)') LINE
              IF(LINE(17:25).EQ.'irregular') THEN
                SIGNAL_REGTYPE(nr,FILEID)=0
C LKC 11-AUG-97   ->read   WRITE(FILEID,
C'('' Number of geometric coordinates: C '','
C     '            //'I1)') NJJT


C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                READ(FILEID,'('' Number of geometric coordinates: '','
C     '            //'I1)') NJJT
                FMT='('' Number of geometric coordinates: '',I1)'
                READ(FILEID,FMT) NJJT

                CALL ASSERT(NJJT.EQ.NJT,
     '            '>>Number of geometric coordinates is not equal'
     '            //' to current number',ERROR,*9999)
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                  READ(FILEID,'(''   Electrode '',I5,'':'','
C     '              //'3(1X,E12.5))') ndd,(ZD(nj,nd),nj=1,NJT)
                  FMT='(''   Electrode '',I5,'':'','
     '              //'3(1X,E12.5))'
                  READ(FILEID,FMT) ndd,(ZD(nj,nd),nj=1,NJT)
                ENDDO
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                  READ(FILEID,'(''   Electrode '',I5,'':'','
C     '              //'3(1X,E12.5))') ndd,(WD(nj,nd),nj=1,NJT)
                  FMT='(''   Electrode '',I5,'':'',3(1X,E12.5))'
                  READ(FILEID,FMT) ndd,(WD(nj,nd),nj=1,NJT)

                ENDDO
                READ(FILEID,'(A)') LINE
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                  READ(FILEID,'(''   Electrode '',I5,'': '',E12.5)')
C     '              ndd,WD(NJT+ZD_OFFSET+1,nd)
                  FMT='(''   Electrode '',I5,'': '',E12.5)'
                  READ(FILEID,FMT) ndd,WD(NJT+ZD_OFFSET+1,nd)
                ENDDO

                READ(FILEID,'(A)') LINE
                IF(LINE(24:26).EQ.'not') THEN
                  SIGNAL_ELEMLOC(FILEID)=0
                ELSE IF(LINE(24:29).EQ.'stored') THEN
                  SIGNAL_ELEMLOC(FILEID)=1
                  IF(SIGNAL_NUMELEC(nr,FILEID).LE.10) THEN

C LKC 11-AUG-97   ->read                   WRITE(FILEID,
C'('' Element numbers:'',10(1X,I5))')
C     '                (LD(NDDATA(nodata,nr)),nodata=1,
C     '                SIGNAL_NUMELEC(nr,FILEID))


C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                    READ(FILEID,'('' Element numbers:'',10(1X,I5))')
C     '                (LD(NDDATA(nodata,nr)),nodata=1,
C     '                SIGNAL_NUMELEC(nr,FILEID))

                    FMT='('' Element numbers:'',10(1X,I5))'
                    READ(FILEID,FMT) (LD(NDDATA(nodata,nr)),nodata=1,
     '                SIGNAL_NUMELEC(nr,FILEID))
                  ELSE

C LKC 11-AUG-97                    WRITE(FILEID,
C'('' Element numbers:'',10(1X,I5),'
C     '                //':/(17X,10(1X,I5)))') (LD(NDDATA(nodata,nr)),
C     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))


C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                    READ(FILEID,'('' Element numbers:'',10(1X,I5),'
C     '                //':/(17X,10(1X,I5)))') (LD(NDDATA(nodata,nr)),
C     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                    FMT='('' Element numbers:'',10(1X,I5),'
     '                //':/(17X,10(1X,I5)))'
                    READ(FILEID,FMT) (LD(NDDATA(nodata,nr)),
     '                nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                  ENDIF

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                  READ(FILEID,'('' Number of Xi coordinates: '',I1)')
C     '              SIGNAL_NUMXI(nr,FILEID)
                  FMT='('' Number of Xi coordinates: '',I1)'
                  READ(FILEID,FMT) SIGNAL_NUMXI(nr,FILEID)
                  CALL ASSERT(SIGNAL_NUMXI(nr,FILEID).LE.NIM,
     '              '>>Increase NIM',ERROR,*9999)

C LKC 13-FEB-1999 Setup NXIDEF - to change when data is region dependant
                  NXIDEF=SIGNAL_NUMXI(nr,FILEID)
C LKC 13-FEB-1999 Setup CALC_XI
                  CALC_XI=.TRUE.

                  IF(CALL_ELEM) THEN
                    noelec=1
                    nd=NDDATA(noelec,nr)
                    FOUND=LD(nd).NE.0
                    DO WHILE(noelec.LE.SIGNAL_NUMELEC(nr,FILEID).AND.
     '                .NOT.FOUND)
                      nd=NDDATA(noelec,nr)
                      IF(LD(nd).NE.0) THEN
                        FOUND=.TRUE.
                      ELSE
                        noelec=noelec+1
                      ENDIF
                    ENDDO
                    IF(FOUND) THEN
                      nb=NBJ(1,LD(nd))
                    ELSE
                      ERROR='>>Could not find electrode projection '
     '                  //'elements'
                      GOTO 9999
                    ENDIF
                    IF(nb.GT.0.AND.nb.LE.NBT) THEN
                      IF(SIGNAL_NUMXI(nr,FILEID).NE.NIT(nb)) THEN
                        WRITE(OP_STRING,'('' >>WARNING: Number of xi '
     '                    //'coordinates is not equal to current '
     '                    //'number'')')
                        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
                      ENDIF
                    ENDIF
                  ENDIF
                  READ(FILEID,'(A)') LINE
                  DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                    nd=NDDATA(nodata,nr)

C LKC 26-JUN-2001 This is invalid FORTRAN - but now works
C                    READ(FILEID,'(''   Electrode '',I5,'':'','
C     '                //'3(1X,E12.5))') ndd,(XID(ni,nd),ni=1,
C     '                SIGNAL_NUMXI(nr,FILEID))
                    FMT='(''   Electrode '',I5,'':'',3(1X,E12.5))'
                    READ(FILEID,FMT) ndd,(XID(ni,nd),ni=1,
     '                SIGNAL_NUMXI(nr,FILEID))
                  ENDDO
                ELSE
                  ERROR='>>Invalid file format'
                  GOTO 9999
                ENDIF
              ELSE
                ERROR='>>Invalid file format'
                GOTO 9999
              ENDIF
            ENDDO !nr

          ELSE
            ERROR='>>Invalid subcommand'
            GOTO 9999
          ENDIF

        ELSE IF(FILEFORMAT(1:6).EQ.'BINARY') THEN

          IF(SUBCOMMAND(1:4).EQ.'OPEN') THEN

C***        Open the signal file
            FILETYPE=3 !Binary signal file
            VERSION(1)=1 !Version 28/10/95
            VERSION(2)=1
            VERSION(3)=0
            CALL OPEN_BIN_FILE(FILEID,FILETYPE,NUMBERTAGS,VERSION,
     '        'READ','sig',FILENAME,ERROR,*9999)
C***        Read the tag header
            CALL READ_BIN_TAG_HEADER(FILEID,ERROR,*9999)
            CALL ASSERT(TAGINDEX.EQ.1,
     '        '>>Signal information header not found',ERROR,*9999)
C***        Read number of signal description bytes
            CALL BINREADFILE(FILEID,INTTYPE,1,
     '        SIGNAL_HEADERBYTES(FILEID),REAL4DATA,REAL8DATA,CHARDATA,
     '        LOGDATA,SINTDATA,ERROR,*9999)
C***        Read the signal description
            CALL BINREADFILE(FILEID,CHARTYPE,SIGNAL_HEADERBYTES(FILEID),
     '        INTDATA,REAL4DATA,REAL8DATA,SIGNAL_HEADER(FILEID),LOGDATA,
     '        SINTDATA,ERROR,*9999)
C***        Read how the signal was generated
            CALL BINREADFILE(FILEID,INTTYPE,1,
     '        SIGNAL_HOWGENERATED(FILEID),REAL4DATA,REAL8DATA,
     '        CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
            IF(SIGNAL_HOWGENERATED(FILEID).EQ.0) THEN !CMISS
C             Do nothing
            ELSE IF(SIGNAL_HOWGENERATED(FILEID).EQ.1) THEN !UNEMAP
C***          Read the number of emap regions
              EMAP_NUMREG(1)=EMAP_NUMREGIONS
              CALL BINREADFILE(FILEID,INTTYPE,1,EMAP_NUMREG,
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,
     '          *9999)
              EMAP_NUMREGIONS=EMAP_NUMREG(1)
C***          Read the emap rig types
              CALL BINREADFILE(FILEID,INTTYPE,EMAP_NUMREGIONS+1,
     '          EMAP_RIGTYPE,REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,
     '          SINTDATA,ERROR,*9999)
C***          Read the number of rig name bytes
              EMAP_NUMRB(1)=EMAP_NUMRIGNAMEBYTES
              CALL BINREADFILE(FILEID,INTTYPE,1,EMAP_NUMRB,
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,
     '          *9999)
              EMAP_NUMRIGNAMEBYTES=EMAP_NUMRB(1)
C***          Read the rig name
              CALL BINREADFILE(FILEID,CHARTYPE,EMAP_NUMRIGNAMEBYTES,
     '          INTDATA,REAL4DATA,REAL8DATA,EMAP_RIGNAME,LOGDATA,
     '          SINTDATA,ERROR,*9999)
C***          Read the sampling frequency
              EMAP_FRQ(1)=EMAP_FREQUENCY
              CALL BINREADFILE(FILEID,DPTYPE,1,INTDATA,REAL4DATA,
     '          EMAP_FRQ,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              EMAP_FREQUENCY=EMAP_FRQ(1)
            ELSE
              ERROR='>>Invalid signal generation code'
              GOTO 9999
            ENDIF
            NUMTIMEDATA=NUMBERTAGS-2

          ELSE IF(SUBCOMMAND(1:5).EQ.'RESET') THEN

C           Reset file to beginning of signal data

            CALL BINSETFILE(FILEID,0,ERROR,*9999)
            CALL BINSKIPCMHEADER(FILEID,3,ERROR,*9999)
C***        Read signal header tag
            CALL READ_BIN_TAG_HEADER(FILEID,ERROR,*9999)
            CALL ASSERT(TAGINDEX.EQ.1,
     '        '>>Signal information header not found',ERROR,*9999)
            CALL BINSKIPFILE(FILEID,NUMTAGBYTES,ERROR,*9999)
C***        Read Electrode geometry tag
            CALL READ_BIN_TAG_HEADER(FILEID,ERROR,*9999)
            CALL ASSERT(TAGINDEX.EQ.2,
     '        '>>Electrode data tag not found',
     '        ERROR,*9999)
            CALL BINSKIPFILE(FILEID,NUMTAGBYTES,ERROR,*9999)

          ELSE IF(SUBCOMMAND(1:11).EQ.'SIGNAL_DATA') THEN

            ENDFILE=.FALSE.
C***        Read the tag header information
 20         CALL READ_BIN_TAG_HEADER(FILEID,ERROR,*9999)
            CALL ASSERT(TAGINDEX.EQ.3,
     '        '>>Signal data tag not found',ERROR,*9999)
C***        Read in the time
            FILETIM(1)=FILETIME
            CALL BINREADFILE(FILEID,DPTYPE,1,INTDATA,REAL4DATA,
     '        FILETIM,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
            FILETIME=FILETIM(1)
C cpb 25/4/97 Implementing reading specified time
            IF(.NOT.NEXTTIME) THEN
              IF(FILETIME.LT.TIME) THEN
                CALL BINSKIPFILE(FILEID,NUMTAGBYTES-DPSIZE,ERROR,*9999)
                IF(ISENDBINFILE(FILEID)) GOTO 9998
                GOTO 20
              ELSE
                TIME=FILETIME
              ENDIF
            ELSE
              TIME=FILETIME
            ENDIF
            CALL ASSERT(NJT+ZD_OFFSET+1.LE.NJM,'>>Increase NJMX',
     '        ERROR,*9999)
C***        Read the electrode data
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              SIGNALMAX(nr)=-RMAX
              SIGNALMIN(nr)=RMAX
              DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                nd=NDDATA(noelec,nr)
                CALL BINREADFILE(FILEID,SPTYPE,1,INTDATA,X,REAL8DATA,
     '            CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ZD(NJT+ZD_OFFSET+1,nd)=DBLE(X(1))
                IF(ZD(NJT+ZD_OFFSET+1,nd).GT.SIGNALMAX(nr))
     '            SIGNALMAX(nr)=ZD(NJT+ZD_OFFSET+1,nd)
                IF(ZD(NJT+ZD_OFFSET+1,nd).LT.SIGNALMIN(nr))
     '            SIGNALMIN(nr)=ZD(NJT+ZD_OFFSET+1,nd)
              ENDDO !noelec
            ENDDO !no_nrlist (nr)

          ELSE IF(SUBCOMMAND(1:14).EQ.'ELECTRODE_DATA') THEN

C***        Read the tag header
            CALL READ_BIN_TAG_HEADER(FILEID,ERROR,*9999)
            CALL ASSERT(TAGINDEX.EQ.2,
     '        '>>Electrode data tag not found',
     '        ERROR,*9999)
C***        Read the number of regions
            CALL BINREADFILE(FILEID,INTTYPE,1,SIGNAL_NUMREGIONS(FILEID),
     '        REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,
     '        *9999)
            CALL ASSERT(SIGNAL_NUMREGIONS(FILEID).LE.NSIGNALREGIONSMX,
     '        '>>Increase NSIGNALREGIONSMX in sign00.cmn',
     '        ERROR,*9999)
            CALL ASSERT(SIGNAL_NUMREGIONS(FILEID).LE.NRM,
     '        '>>Increase NRMX',ERROR,*9999)
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
C***          Read the number of region description bytes
              NUMBTS(1)=NUMBYTES
              CALL BINREADFILE(FILEID,INTTYPE,1,NUMBTS,REAL4DATA,
     '          REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              NUMBYTES=NUMBTS(1)
              CALL ASSERT(NUMBYTES.LE.30,
     '          '>>Increase length of signal region name in sign00.cmn',
     '          ERROR,*9999)
C***          Read the region description
              CALL BINREADFILE(FILEID,CHARTYPE,NUMBYTES,INTDATA,
     '          REAL4DATA,REAL8DATA,SIGNAL_REGNAME(nr,FILEID),
     '          LOGDATA,SINTDATA,ERROR,*9999)
C***          Read the number of electrodes
              CALL BINREADFILE(FILEID,INTTYPE,1,
     '          SIGNAL_NUMELEC(nr,FILEID),REAL4DATA,REAL8DATA,
     '          CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              CALL ASSERT(USE_DATA.GT.0,'>>Set USE_DATA to 1',ERROR,
     '          *9999)
              CALL ASSERT(SIGNAL_NUMELEC(nr,FILEID).LE.NDM,
     '          '>>Increase NDM',ERROR,*9999)
C***          Read the electrode identity numbers
C cpb 28/10/95 Data points are not really region dependent as such.
C Use a NDDATA array to idendify electrodes
              NDDATA(0,nr)=SIGNAL_NUMELEC(nr,FILEID)
              CALL BINREADFILE(FILEID,INTTYPE,SIGNAL_NUMELEC(nr,FILEID),
     '          NDDATA(1,nr),REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,
     '          SINTDATA,ERROR,*9999)

C LKC 31-AUG-1999 does not work if non-sequential electrode numbers
C
C              DO nodata=1,NDDATA(0,nr)
C                nd=NDDATA(nodata,nr)
C                IF(nd.GT.NDT) NDT=nd
C              ENDDO !nodata (nd)
              NDT=NDDATA(0,nr)

              CALL ASSERT(NDT.LE.NDM,'>>Increase NDM',ERROR,*9999)
C***          Read the region type
              CALL BINREADFILE(FILEID,INTTYPE,1,
     '          SIGNAL_REGTYPE(nr,FILEID),
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,
     '          ERROR,*9999)
              IF(SIGNAL_REGTYPE(nr,FILEID).EQ.0) THEN !irreg rect. cart.
C***            Read the number of geometric coordinates
                NJJT2(1)=NJJT
                CALL BINREADFILE(FILEID,INTTYPE,1,NJJT2,
     '            REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,
     '            ERROR,*9999)
                NJJT=NJJT2(1)
                CALL ASSERT(NJJT.EQ.NJT,
     '            '>>Number of geometric coordinates is not equal'
     '            //' to current number',ERROR,*9999)
C***            Read the geometric coordinates of the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINREADFILE(FILEID,SPTYPE,NJT,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                  DO nj=1,NJT
                    ZD(nj,nd)=DBLE(X(nj))
                  ENDDO !nj
                ENDDO !noelec
C***            Read the weights for the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINREADFILE(FILEID,SPTYPE,NJT,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                  DO nj=1,NJT
                    WD(nj,nd)=DBLE(X(nj))
                  ENDDO !nj
                ENDDO !noelec
C***            Read the signal weights for the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINREADFILE(FILEID,SPTYPE,1,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                  WD(NJT+ZD_OFFSET+1,nd)=DBLE(X(1))
                ENDDO !noelec
              ELSE
                ERROR='>>Unknown signal region type'
                GOTO 9999
              ENDIF
C***          Read whether the electrodes have element locations
              CALL BINREADFILE(FILEID,INTTYPE,1,SIGNAL_ELEMLOC(FILEID),
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,
     '          ERROR,*9999)
              IF(SIGNAL_ELEMLOC(FILEID).EQ.0) THEN
C               Do nothing
              ELSE IF(SIGNAL_ELEMLOC(FILEID).EQ.1) THEN
C***            Read the electrode elements
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINREADFILE(FILEID,INTTYPE,1,LD(nd),REAL4DATA,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
C***            Read the number of xi coordinates
                CALL BINREADFILE(FILEID,INTTYPE,1,
     '            SIGNAL_NUMXI(nr,FILEID),REAL4DATA,REAL8DATA,CHARDATA,
     '            LOGDATA,SINTDATA,ERROR,*9999)
                CALL ASSERT(SIGNAL_NUMXI(nr,FILEID).LE.NIM,
     '            '>>Increase NIM',ERROR,*9999)

C LKC 13-FEB-1999 Setup NXIDEF - to change when data is region dependant
                NXIDEF=SIGNAL_NUMXI(nr,FILEID)
C LKC 13-FEB-1999 Setup CALC_XI
                CALC_XI=.TRUE.

                IF(CALL_ELEM) THEN
                  noelec=1
                  nd=NDDATA(noelec,nr)
                  FOUND=LD(nd).NE.0
                  DO WHILE(noelec.LE.SIGNAL_NUMELEC(nr,FILEID).AND.
     '              .NOT.FOUND)
                    nd=NDDATA(noelec,nr)
                    IF(LD(nd).NE.0) THEN
                      FOUND=.TRUE.
                    ELSE
                      noelec=noelec+1
                    ENDIF
                  ENDDO
                  IF(FOUND) THEN
                    nb=NBJ(1,LD(nd))
                  ELSE
                    ERROR='>>Could not find electrode projection '
     '                //'elements'
                    GOTO 9999
                  ENDIF
                  IF(nb.GT.0.AND.nb.LE.NBT) THEN
                    IF(SIGNAL_NUMXI(nr,FILEID).NE.NIT(nb)) THEN
                      WRITE(OP_STRING,'('' >>WARNING: Number of xi '
     '                //'coordinates is not equal to current number'')')
                      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
                    ENDIF
                  ENDIF
                ENDIF
C***            Read the xi coordinates
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINREADFILE(FILEID,SPTYPE,
     '              SIGNAL_NUMXI(nr,FILEID),INTDATA,X,REAL8DATA,
     '              CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                  DO ni=1,SIGNAL_NUMXI(nr,FILEID)
                    XID(ni,nd)=DBLE(X(ni))
                  ENDDO !ni
                ENDDO !noelec
              ELSE
                ERROR='>>Invalid signal element location indicator'
                GOTO 9999
              ENDIF
            ENDDO !nr

          ELSE
            ERROR='>>Invalid subcommand'
            GOTO 9999
          ENDIF

        ELSE
          ERROR='>>Invalid file format'
          GOTO 9999
        ENDIF

      ELSE IF(COMMAND(1:5).EQ.'WRITE') THEN

        IF(FILEFORMAT(1:5).EQ.'ASCII') THEN

          IF(SUBCOMMAND(1:4).EQ.'OPEN') THEN

            OLDIOTYPE=IOTYPE
            IOTYPE=3 !Write
            VERSION(1)=1 !4/5/97
            CALL OPEN_SEQ_FILE(VERSION(1),FILEID,FILENAME,
     '        'sign','NEW',.FALSE.,ERROR,*9999)
            IOTYPE=OLDIOTYPE

            CALL STRING_TRIM(SIGNAL_HEADER(FILEID),IBEG,IEND)
C LKC 11-FEB-1999 if no Generation information ...
C              WRITE(FILEID,'('' Generation information : '',A)')
C     '          SIGNAL_HEADER(FILEID)(IBEG:IEND)
            IF(IBEG.LT.IEND) THEN
              WRITE(FILEID,'('' Generation information : '',A)')
     '          SIGNAL_HEADER(FILEID)(IBEG:IEND)
            ELSE
              WRITE(FILEID,'('' Generation information : None'')')
            ENDIF

            IF(SIGNAL_HOWGENERATED(FILEID).EQ.0) THEN
              WRITE(FILEID,'(/'' Signal was generated by CMISS'')')
            ELSE IF(SIGNAL_HOWGENERATED(FILEID).EQ.1) THEN
              WRITE(FILEID,'(/'' Signal was generated by UnEmap'')')
              WRITE(FILEID,'('' Number of UnEmap regions: '',I2)')
     '          EMAP_NUMREGIONS
              WRITE(FILEID,'('' UnEmap rig types:'',10(1X,I2))')
     '          (EMAP_RIGTYPE(nr),nr=0,EMAP_NUMREGIONS)
              CALL STRING_TRIM(EMAP_RIGNAME,IBEG,IEND)
              WRITE(FILEID,'('' UnEmap rig name: '',A)')
     '          EMAP_RIGNAME(IBEG:IEND)
              WRITE(FILEID,'('' UnEmap sampling frequency (Hz): '','
     '          //'D12.5)') EMAP_FREQUENCY
            ELSE
              ERROR='>>Invalid generation code'
              GOTO 9999
            ENDIF
            NUMTIMEDATA=0

          ELSE IF(SUBCOMMAND(1:11).EQ.'SIGNAL_DATA') THEN

            WRITE(FILEID,'(/,'' Time = '',D11.4)') TIME
            WRITE(FILEID,'('' Signal Data:'')')
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              WRITE(FILEID,'(1X,5(1X,E12.5),:/(1X,5(1X,E12.5)))')
     '          (ZD(NJT+ZD_OFFSET+1,NDDATA(nodata,nr)),nodata=1,
     '          SIGNAL_NUMELEC(nr,FILEID))
            ENDDO !nr
            NUMTIMEDATA=NUMTIMEDATA+1

          ELSE IF(SUBCOMMAND(1:14).EQ.'ELECTRODE_DATA') THEN

            WRITE(FILEID,'(/'' Number of electrode regions: '',I2)')
     '        SIGNAL_NUMREGIONS(FILEID)
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              WRITE(FILEID,'(/'' Region: '',I2)') nr
              CALL STRING_TRIM(SIGNAL_REGNAME(nr,FILEID),IBEG,IEND)
              WRITE(FILEID,'('' Region description: '',A)')
     '          SIGNAL_REGNAME(nr,FILEID)(IBEG:IEND)
              WRITE(FILEID,'('' Number of electrodes: '',I5)')
     '          SIGNAL_NUMELEC(nr,FILEID)
              WRITE(FILEID,'('' Electrode numbers:'',10(1X,I5),'
     '          //':/(19X,10(1X,I5)))') (NDDATA(nodata,nr),nodata=1,
     '          SIGNAL_NUMELEC(nr,FILEID))
              IF(SIGNAL_REGTYPE(nr,FILEID).EQ.0) THEN
                WRITE(FILEID,'('' Region type is irregular '
     '            //'rectangular cartesian'')')
                WRITE(FILEID,'('' Number of geometric coordinates: '','
     '            //'I1)') NJT
                WRITE(FILEID,'('' Electrode coordinates:'')')
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)
                  WRITE(FILEID,'(''   Electrode '',I5,'':'','
     '              //'3(1X,E12.5))') nd,(ZD(nj,nd),nj=1,NJT)
                ENDDO
                WRITE(FILEID,'('' Electrode coordinate weights:'')')
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)
                  WRITE(FILEID,'(''   Electrode '',I5,'':'','
     '              //'3(1X,E12.5))') nd,(WD(nj,nd),nj=1,NJT)
                ENDDO
                WRITE(FILEID,'('' Electrode weights:'')')
                DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(nodata,nr)
                  WRITE(FILEID,'(''   Electrode '',I5,'': '',E12.5)')
     '              nd,WD(NJT+ZD_OFFSET+1,nd)
                ENDDO
                IF(SIGNAL_ELEMLOC(FILEID).EQ.0) THEN
                  WRITE(FILEID,'('' Element locations are not '
     '              //'stored'')')
                ELSE IF(SIGNAL_ELEMLOC(FILEID).EQ.1) THEN
                  WRITE(FILEID,'('' Element locations are stored'')')
                  WRITE(FILEID,'('' Element numbers:'',10(1X,I5),'
     '              //':/(17X,10(1X,I5)))') (LD(NDDATA(nodata,nr)),
     '              nodata=1,SIGNAL_NUMELEC(nr,FILEID))
                  WRITE(FILEID,'('' Number of Xi coordinates: '',I1)')
     '              SIGNAL_NUMXI(nr,FILEID)
                  WRITE(FILEID,'('' Xi coordinates:'')')
                  DO nodata=1,SIGNAL_NUMELEC(nr,FILEID)
                    nd=NDDATA(nodata,nr)
                    WRITE(FILEID,'(''   Electrode '',I5,'':'','
     '                //'3(1X,E12.5))') nd,(XID(ni,nd),ni=1,
     '                SIGNAL_NUMXI(nr,FILEID))
                  ENDDO
                ELSE
                  ERROR='>>Invalid location code'
                  GOTO 9999
                ENDIF
              ELSE
                ERROR='>>Invalid region type'
                GOTO 9999
              ENDIF
            ENDDO !nr

          ELSE
            ERROR='>>Invalid subcommand'
            GOTO 9999
          ENDIF

        ELSE IF(FILEFORMAT(1:6).EQ.'BINARY') THEN

          IF(SUBCOMMAND(1:4).EQ.'OPEN') THEN

C***        Open the signal file for writing
            FILETYPE=3 !Binary signal file
            VERSION(1)=1 !Version 23/10/95
            VERSION(2)=1
            VERSION(3)=0
            NUMBERTAGS=1 !Just header tag for the moment.
            CALL OPEN_BIN_FILE(FILEID,FILETYPE,NUMBERTAGS,VERSION,
     '        'WRITE','sig',FILENAME,ERROR,*9999)
C***        Write the tag header
            TAGINDEX=1
            TAGHEADER='Signal generation information'
            CALL STRING_TRIM(SIGNAL_HEADER(FILEID),IBEG,IEND)
C LKC 11-FEB-1999 If no generation information
C            IF(IBEG.GT.IEND) THEN
C
            IF(IBEG.GE.IEND) THEN
              SIGNAL_HEADERBYTES(FILEID)=0
            ELSE IF(IBEG.EQ.IEND.AND.
     '          SIGNAL_HEADER(FILEID)(IBEG:IEND).EQ.' ') THEN
              SIGNAL_HEADERBYTES(FILEID)=0
            ELSE
              SIGNAL_HEADERBYTES(FILEID)=IEND-IBEG+1
            ENDIF
            NUMBERSUBTAGS=0
            NUMTAGBYTES=INTSIZE+SIGNAL_HEADERBYTES(FILEID)*CHARSIZE+
     '        INTSIZE
            IF(SIGNAL_HOWGENERATED(FILEID).EQ.1) THEN
              NUMTAGBYTES=NUMTAGBYTES+INTSIZE+(EMAP_NUMREGIONS+1)*
     '          INTSIZE+INTSIZE+EMAP_NUMRIGNAMEBYTES*CHARSIZE+DPSIZE
            ENDIF
            CALL WRITE_BIN_TAG_HEADER(FILEID,ERROR,*9999)
C***        Write number of signal description bytes
            CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '        SIGNAL_HEADERBYTES(FILEID),REAL4DATA,REAL8DATA,
     '        CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
C***        Write the signal description
            CALL BINWRITEFILE(FILEID,CHARTYPE,
     '        SIGNAL_HEADERBYTES(FILEID),INTDATA,REAL4DATA,REAL8DATA,
     '        SIGNAL_HEADER(FILEID),LOGDATA,SINTDATA,ERROR,*9999)
C***        Write how the signal was generated
            CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '        SIGNAL_HOWGENERATED(FILEID),REAL4DATA,REAL8DATA,
     '        CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
            IF(SIGNAL_HOWGENERATED(FILEID).EQ.1) THEN !UNEMAP
C***          Write the number of emap regions
              EMAP_NUMREG(1)=EMAP_NUMREGIONS
              CALL BINWRITEFILE(FILEID,INTTYPE,1,EMAP_NUMREG,
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,
     '          *9999)
              EMAP_NUMREGIONS=EMAP_NUMREG(1)
C***          Write the emap rig types
              CALL BINWRITEFILE(FILEID,INTTYPE,EMAP_NUMREGIONS+1,
     '          EMAP_RIGTYPE,REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,
     '          SINTDATA,ERROR,*9999)
C***          Write the number of rig name bytes
              EMAP_NUMRB(1)=EMAP_NUMRIGNAMEBYTES
              CALL BINWRITEFILE(FILEID,INTTYPE,1,EMAP_NUMRB,
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,
     '          *9999)
              EMAP_NUMRIGNAMEBYTES=EMAP_NUMRB(1)
C***          Write the rig name
              CALL BINWRITEFILE(FILEID,CHARTYPE,EMAP_NUMRIGNAMEBYTES,
     '          INTDATA,REAL4DATA,REAL8DATA,EMAP_RIGNAME,LOGDATA,
     '          SINTDATA,ERROR,*9999)
C***          Write the sampling frequency
              EMAP_FRQ(1)=EMAP_FREQUENCY
              CALL BINWRITEFILE(FILEID,DPTYPE,1,INTDATA,REAL4DATA,
     '          EMAP_FRQ,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              EMAP_FREQUENCY=EMAP_FRQ(1)
            ENDIF
            NUMTIMEDATA=0

          ELSE IF(SUBCOMMAND(1:11).EQ.'SIGNAL_DATA') THEN

C***        Set the number of tags in the file
            NUMTIMEDATA=NUMTIMEDATA+1 !Adjust the number of times
            NUMBERTAGS=NUMTIMEDATA+2 !Adjust the number of tags
            CALL BINRESETNUMTAG(FILEID,NUMBERTAGS,ERROR,*9999)
C***        Write the tag header
            TAGINDEX=3
            TAGHEADER='Signal Data'
            NUMBERSUBTAGS=0
            NUMTAGBYTES=DPSIZE
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              NUMTAGBYTES=NUMTAGBYTES+SIGNAL_NUMELEC(nr,FILEID)*SPSIZE
            ENDDO !no_nrlist (nr)
            CALL WRITE_BIN_TAG_HEADER(FILEID,ERROR,*9999)
C***        Write the time
            TIME2(1)=TIME
            CALL BINWRITEFILE(FILEID,DPTYPE,1,INTDATA,REAL4DATA,
     '        TIME2,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
            TIME=TIME2(1)
C***        Write the electrode data
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                nd=NDDATA(noelec,nr)
                DUMMY1(1)=REAL(ZD(NJT+ZD_OFFSET+1,nd))
                CALL BINWRITEFILE(FILEID,SPTYPE,1,INTDATA,
     '            DUMMY1,REAL8DATA,CHARDATA,
     '            LOGDATA,SINTDATA,ERROR,*9999)
C                CALL BINWRITEFILE(FILEID,SPTYPE,1,INTDATA,
C     '            REAL(ZD(NJT+ZD_OFFSET+1,nd)),REAL8DATA,CHARDATA,
C     '            LOGDATA,SINTDATA,ERROR,*9999)
              ENDDO !noelec
            ENDDO !no_nrlist (nr)

          ELSE IF(SUBCOMMAND(1:14).EQ.'ELECTRODE_DATA') THEN

C***        Set the number of tags in the file
            NUMBERTAGS=2
            CALL BINRESETNUMTAG(FILEID,NUMBERTAGS,ERROR,*9999)
C***        Write the tag header
            TAGINDEX=2
            TAGHEADER='Electrode Data'
            NUMBERSUBTAGS=0
            NUMTAGBYTES=INTSIZE
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
              CALL STRING_TRIM(SIGNAL_REGNAME(nr,FILEID),IBEG,IEND)
              IF(IBEG.GT.IEND) THEN
                NUMBYTES=0
              ELSE IF(IBEG.EQ.IEND.AND.
     '            SIGNAL_REGNAME(nr,FILEID)(IBEG:IEND).EQ.' ') THEN
                NUMBYTES=0
              ELSE
                NUMBYTES=IEND-IBEG+1
              ENDIF
              NUMTAGBYTES=NUMTAGBYTES+INTSIZE+NUMBYTES*CHARSIZE+
     '          INTSIZE+SIGNAL_NUMELEC(nr,FILEID)*INTSIZE+INTSIZE
              IF(SIGNAL_REGTYPE(nr,FILEID).EQ.0) THEN !irreg rect. cart.
                NUMTAGBYTES=NUMTAGBYTES+INTSIZE+NJT*
     '            SIGNAL_NUMELEC(nr,FILEID)*SPSIZE+NJT*
     '            SIGNAL_NUMELEC(nr,FILEID)*SPSIZE+
     '            SIGNAL_NUMELEC(nr,FILEID)*SPSIZE
              ENDIF
              NUMTAGBYTES=NUMTAGBYTES+INTSIZE
              IF(SIGNAL_ELEMLOC(FILEID).EQ.1) THEN
                NUMTAGBYTES=NUMTAGBYTES+SIGNAL_NUMELEC(nr,FILEID)*
     '            INTSIZE+INTSIZE+SIGNAL_NUMXI(nr,FILEID)*
     '            SIGNAL_NUMELEC(nr,FILEID)*SPSIZE
              ENDIF
            ENDDO !no_nrlist (nr)
            CALL WRITE_BIN_TAG_HEADER(FILEID,ERROR,*9999)
C***        Write the number of regions
            CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '        SIGNAL_NUMREGIONS(FILEID),REAL4DATA,REAL8DATA,
     '        CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
            DO nr=1,SIGNAL_NUMREGIONS(FILEID)
C***          Write the number of region description bytes
              CALL STRING_TRIM(SIGNAL_REGNAME(nr,FILEID),IBEG,IEND)
              IF(IBEG.GT.IEND) THEN
                NUMBYTES=0
              ELSE IF(IBEG.EQ.IEND.AND.
     '            SIGNAL_REGNAME(nr,FILEID)(IBEG:IEND).EQ.' ') THEN
                NUMBYTES=0
              ELSE
                NUMBYTES=IEND-IBEG+1
              ENDIF
              NUMBTS(1)=NUMBYTES
              CALL BINWRITEFILE(FILEID,INTTYPE,1,NUMBTS,REAL4DATA,
     '          REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              NUMBYTES=NUMBTS(1)
C***          Write the region description
              CALL BINWRITEFILE(FILEID,CHARTYPE,NUMBYTES,INTDATA,
     '          REAL4DATA,REAL8DATA,SIGNAL_REGNAME(nr,FILEID),
     '          LOGDATA,SINTDATA,ERROR,*9999)
C***          Write the number of electrodes
              CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '          SIGNAL_NUMELEC(nr,FILEID),REAL4DATA,REAL8DATA,
     '          CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
C***          Write the electrode identity numbers
C cpb 28/10/95 Data points are not really region dependent as such.
C Use a NDDATA array to idendify electrodes
              CALL BINWRITEFILE(FILEID,INTTYPE,
     '          SIGNAL_NUMELEC(nr,FILEID),NDDATA(1,nr),REAL4DATA,
     '          REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
C***          Write the region type
              CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '          SIGNAL_REGTYPE(nr,FILEID),REAL4DATA,REAL8DATA,
     '          CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
              IF(SIGNAL_REGTYPE(nr,FILEID).EQ.0) THEN !irreg rect. cart.
C***            Write the number of geometric coordinates
                NJJT2(1)=NJT
                CALL BINWRITEFILE(FILEID,INTTYPE,1,NJJT2,
     '            REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,
     '            ERROR,*9999)
C***            Write the geometric coordinates of the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  DO nj=1,NJT
                    X(nj)=REAL(ZD(nj,nd))
                  ENDDO !nj
                  CALL BINWRITEFILE(FILEID,SPTYPE,NJT,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
C***            Write the weights for the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  DO nj=1,NJT
                    X(nj)=REAL(WD(nj,nd))
                  ENDDO !nj
                  CALL BINWRITEFILE(FILEID,SPTYPE,NJT,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
C***            Write the signal weights for the electrodes
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  X(1)=REAL(WD(NJT+ZD_OFFSET+1,nd))
                  CALL BINWRITEFILE(FILEID,SPTYPE,1,INTDATA,X,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
              ENDIF
C***          Write whether the electrodes have element locations
              CALL BINWRITEFILE(FILEID,INTTYPE,1,SIGNAL_ELEMLOC(FILEID),
     '          REAL4DATA,REAL8DATA,CHARDATA,LOGDATA,SINTDATA,
     '          ERROR,*9999)
              IF(SIGNAL_ELEMLOC(FILEID).EQ.1) THEN
C***            Write the electrode elements
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  CALL BINWRITEFILE(FILEID,INTTYPE,1,LD(nd),REAL4DATA,
     '              REAL8DATA,CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
C***            Write the number of xi coordinates
                CALL BINWRITEFILE(FILEID,INTTYPE,1,
     '            SIGNAL_NUMXI(nr,FILEID),REAL4DATA,REAL8DATA,
     '            CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
C***            Write the xi coordinates
                DO noelec=1,SIGNAL_NUMELEC(nr,FILEID)
                  nd=NDDATA(noelec,nr)
                  DO ni=1,SIGNAL_NUMXI(nr,FILEID)
                    X(ni)=REAL(XID(ni,nd))
                  ENDDO !nI
                  CALL BINWRITEFILE(FILEID,SPTYPE,
     '              SIGNAL_NUMXI(nr,FILEID),INTDATA,X,REAL8DATA,
     '              CHARDATA,LOGDATA,SINTDATA,ERROR,*9999)
                ENDDO !noelec
              ENDIF
            ENDDO !nr

          ELSE
            ERROR='>>Invalid subcommand'
            GOTO 9999
          ENDIF

        ELSE
          ERROR='>>Invalid file format'
          GOTO 9999
        ENDIF

      ELSE IF(COMMAND(1:5).EQ.'CLOSE') THEN

        IF(FILEFORMAT(1:5).EQ.'ASCII') THEN

          CALL CLOSEF(FILEID,ERROR,*9999)

        ELSE IF(FILEFORMAT(1:6).EQ.'BINARY') THEN

          CALL BINARYCLOSEFILE(FILEID,ERR,CERROR)
          IF(ERR.NE.0) THEN
            CALL CSTRINGLEN(CERRLEN,CERROR)
            CALL C2FSTRING(CERROR,CERRLEN,ERROR)
            GOTO 9999
          ENDIF

        ELSE
          ERROR='>>Invalid file format'
          GOTO 9999
        ENDIF

      ELSE
        ERROR='>>Invalid command'
        GOTO 9999
      ENDIF

      CALL EXITS('IOSIGN')
      RETURN
 9998 ENDFILE=.TRUE.
      CALL EXITS('IOSIGN')
      RETURN
 9999 CALL ERRORS('IOSIGN',ERROR)
      CALL EXITS('IOSIGN')
      IF(ISBINFILEOPEN(FILEID)) CALL BINARYCLOSEFILE(FILEID,ERR,CERROR)
      RETURN 1
      END


