
\section{Linear Solvers}\label{s1.0}

A system of linear equations may be written as a matrix operation
\begin{equation}\label{e1.0}
\mathbf{A \, x = b},
\end{equation}
where $\mathbf{A}$ is a $m$ by $n$ matrix, 
$\mathbf{x}$ is a vector of $n$ unknowns,
and $\mathbf{b}$ is a vector of length $m$. 
Each row of $\mathbf{A}$ is a linear equation in $\mathbf{x}$. 
The aim of the linear solver is for a given system $\mathbf{A}$ and
right hand side $\mathbf{b}$, to determine $\mathbf{x}$.

Normally $\mathbf{A}$ is a square matrix, and $m = n$. However, cases
where there are more equations than unknowns (an over-determined case, $m > n$)
or where there are less equations than unknowns (an under-determined case, 
$m < n$) may be solved in a least squares sense, minimising 
$(b - \mathbf{A \, x})^2$.

\subsection{An Overview of the CMISS Solvers}\label{s1.1}

There are two main divisions within the linear solvers used within CMISS, 
based on equation storage and solution technique.

The matrix $\mathbf{A}$ is stored in one of two ways, either Dense or Sparse
compressed row storage. For Dense storage every element of the matrix is 
stored in a Fortran two dimensional array. This minimises the problems
of accessing data, and is efficient when most of $\mathbf{A}$ contains non-zero 
values (as is the case with equations resulting from boundary element problems
for example). However, for systems that are generated by finite difference or 
finite element problems, most of the matrix $\mathbf{A}$ contains zero values,
and it is inefficient both in terms of storage and number of operations to
store and operate upon the zero values. For this case CMISS used a compressed 
row storage scheme.

For the linear solvers, there are two main classes of solver; direct and 
iterative methods. Direct solvers solve a system in a predictable number of 
operations, whereas iterative methods apply some operation to the system
a number of times until the desired accuracy is achieved. An example of
a direct solver is $\mathbf{L \, U}$ decomposition, whereas the Conjugate 
Gradient solver is an iterative solver. For Dense systems direct solvers are 
typically used, whereas for sparse systems iterative methods are more commonly 
used, especially in cases where a good approximation to the solution is 
available (as is the case in many time marching methods).

For Dense systems, CMISS provides access to the LAPACK direct solvers.
These are provided for most platforms by the machine vendors, and are 
stable and efficient. The solvers available are $\mathbf{L \, U}$ decomposition,
Cholesky factorisation, a Least Squares solver using a $\mathbf{Q \, R}$ or
$\mathbf{L \, Q}$ factorisation, and a least squares solution using Singular
Value Decomposition (SVD).

For sparse systems there are two direct solvers based on $\mathbf{L \, U}$ 
decomposition; Umfpack and SuperLU. Umfpack seems better on single processor 
machines, but SuperLU is available in a parallel form and will run on 
the shared memory multiprocessor machines that CMISS runs on.

Alternatively, for sparse systems there are several iterative solvers
implemented locally. For Symmetric systems the Conjugate Gradient solver 
is available, and the BiCGSTAB and GMRES solvers are available for 
non-symmetric systems. These solvers can either run without preconditioning, 
or combined with various preconditioners based on Incomplete factorisations, 
or SOR and Jacobi preconditioners.


