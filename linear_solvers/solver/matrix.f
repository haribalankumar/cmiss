
      SUBROUTINE CHECK_SOLN(A,LDA,N,B,X,SPARSE_A,ISC_A,ISR_A,ERROR,*)

C#### Subroutine: CHECK_SOLN
C###  Description:
C###    Check the solution generated by a linear solver.
C###  Written by Stuart Norris 04/04/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER LDA,N,SPARSE_A,ISC_A(*),ISR_A(*)
      REAL*8 A(*),B(*),X(*)
      CHARACTER ERROR*(*)
!     Local Constants
      INTEGER NORMTYPE
      PARAMETER(NORMTYPE=2)
!     Local Variables
      INTEGER NZA
      REAL*8 RNORM,SCALED_RNORM,ANORM,BNORM,XNORM,TMP,R(N)
!     Functions
      REAL*8 DNRM2
      EXTERNAL DNRM2


      CALL CALC_MAT_NORM(ANORM,A,LDA,N,SPARSE_A,ISC_A,ISR_A,NORMTYPE,
     '  ERROR,*9999)
      CALL CALC_RESIDUAL(A,LDA,N,X,B,R,SPARSE_A,ISC_A,ISR_A,ERROR,*9999)

      BNORM=DNRM2(N,B,1)
      RNORM=DNRM2(N,R,1)
      XNORM=DNRM2(N,X,1)

      IF(SPARSE_A.EQ.0) THEN
        NZA=N**2
      ELSE
        NZA=ISR_A(N+1)-1
      ENDIF

C     Calculated a norm scaled as per the iterative solvers
      TMP=ANORM*XNORM + BNORM
      IF(ANORM.EQ.0.0D0) THEN
        WRITE(OP_STRING,'(A)') 'CHECK_SOLN: Warning, Null system'
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ENDIF
      IF(TMP.EQ.0.0) TMP=1.0D0
      SCALED_RNORM=RNORM/TMP

      WRITE(OP_STRING,'(A)') ' '
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A)') ' Accuracy of solution'
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A)') ' '
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,G12.6)') '  |r|          : ',RNORM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,G12.6)') '  |r|(scaled)  : ',SCALED_RNORM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,G12.6)') '  |A|          : ',ANORM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,G12.6)') '  |b|          : ',BNORM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,G12.6)') '  |x|          : ',XNORM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A)') ' '
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      WRITE(OP_STRING,'(A,1P,I12)') '  No. Columns  : ',N
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A,1P,I12)') '  No. Elements : ',NZA
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'(A)') ' '
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      RETURN

 9999 CALL ERRORS('CHECK_SOLN',ERROR)
      RETURN 1
      END


      SUBROUTINE CHECK_MATRIX(A,LDA,N,SPARSE_A,ISC_A,ISR_A,ERROR,*)

C#### Subroutine: CHECK_MATRIX
C###  Description:
C###    Check the properties of a matrix
C###  Written by Stuart Norris 07/08/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER LDA,N,SPARSE_A,ISC_A(*),ISR_A(*)
      REAL*8 A(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER NROWS,NCOLS,NZERO,NELEM,NPHYS,NZROW,NERR,NZDIAG,NEDIAG,IDX
      INTEGER I,J,IJ,NZA,IMIN,IMAX,IAVE,NUNSORT_ELEM,NUNSORT_ROW,NR,NREP
      INTEGER*8 NTOTAL
      REAL*8 AIJ,CSUM,RSUM,PELEM,PZERO,PFILL,COL(N),DIAG
      REAL*8 RATIO,RATIO_MIN,RATIO_MAX,RATIO_AVE,MAX_DBLE,EPS_DBLE
      LOGICAL HAVE_DIAG,UNSORTED
!     External routines
      REAL*8 DASUM,DLAMCH
      EXTERNAL DASUM,DLAMCH


      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'('' Summary of Linear System properties'')')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      IF(SPARSE_A.EQ.0) THEN
        WRITE(OP_STRING,'('' Dense Linear System'')')
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        NZA=N**2
      ELSE
        WRITE(OP_STRING,'('' Sparse Linear System'')')
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        NZA=ISR_A(N+1)-1
      ENDIF

      EPS_DBLE=DLAMCH('E')
      MAX_DBLE=DLAMCH('O')

      NROWS=0
      NCOLS=0
      NZERO=0
      NELEM=0
      NPHYS=0
      NZROW=0
      NZDIAG=0
      NEDIAG=0
      NERR=0
      NREP=0
      NR=0
      NUNSORT_ELEM=0
      NUNSORT_ROW=0
      RATIO_MIN=MAX_DBLE
      RATIO_MAX=-MAX_DBLE
      RATIO_AVE=0.0D0

C     Non-sparse matricies
      IF(SPARSE_A.EQ.0) THEN

C$OMP   PARALLEL DO PRIVATE(I,J,AIJ,RSUM,CSUM,DIAG,RATIO),
C$OMP'    REDUCTION(+:NROWS,NCOLS,NZERO,NZDIAG,NR,RATIO_AVE),
C$OMP'    REDUCTION(MIN:RATIO_MIN), REDUCTION(MAX:RATIO_MAX),
C$OMP'    SHARED(N,LDA)
        DO I=1,N

C         Calculate row/col sums, and fill data
          RSUM=DASUM(N,A(I),LDA)
          IF(RSUM.LE.EPS_DBLE) THEN
            NROWS=NROWS+1
          ENDIF

          CSUM=DASUM(N,A((I-1)*LDA+1),1)
          IF(CSUM.LE.EPS_DBLE) THEN
            NCOLS=NCOLS+1
          ENDIF

          DO J=1,N
            AIJ=ABS(A(J+(I-1)*LDA))
            IF(AIJ.LE.EPS_DBLE) NZERO=NZERO+1
          ENDDO

          DIAG=ABS(A(I+LDA*(I-1)))
          IF(DIAG.LE.EPS_DBLE) NZDIAG=NZDIAG+1

C         Calculate the diagonal dominance data
          RSUM=RSUM-DIAG*(1.0D0+EPS_DBLE)
          IF(RSUM.GT.EPS_DBLE) THEN
            RATIO=DIAG/RSUM
            NR=NR+1
            RATIO_AVE=RATIO_AVE+RATIO
          ELSE IF(DIAG.LE.EPS_DBLE) THEN
            RATIO=0.0D0
          ELSE
            RATIO=MAX_DBLE
          ENDIF
          RATIO_MIN=MIN(RATIO_MIN,RATIO)
          RATIO_MAX=MAX(RATIO_MAX,RATIO)
        ENDDO
C$OMP   END PARALLEL DO
        RATIO_AVE=RATIO_AVE/DBLE(NR)
        NPHYS=N**2
        NELEM=NPHYS-NZERO

C     Sparse matricies: CMISS compressed row
      ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN

C$OMP   PARALLEL DO PRIVATE(J)
        DO J=1,N
          COL(J)=0.0D0
        ENDDO
C$OMP   END PARALLEL DO

C$OMP   PARALLEL DO
C$OMP'    PRIVATE(I,J,IDX,AIJ,RSUM,CSUM,DIAG,RATIO,HAVE_DIAG,UNSORTED),
C$OMP'    SHARED(N,LDA),
C$OMP'    REDUCTION(+:NROWS,NCOLS,NZERO,NZDIAG,NR,RATIO_AVE,NELEM,NERR,
C$OMP'      NREP,NZROW,NEDIAG,NUNSORT_ELEM,NUNSORT_ROW),
C$OMP'    REDUCTION(MIN:RATIO_MIN), REDUCTION(MAX:RATIO_MAX)
        DO I=1,N

C         Calculate row/col sums, and fill data
          HAVE_DIAG=.FALSE.
          UNSORTED=.FALSE.
          DIAG=0.0D0

          RSUM=0.0D0
          IDX=0
          DO IJ=ISR_A(I),ISR_A(I+1)-1
            AIJ=ABS(A(IJ))

            IF(AIJ.LE.EPS_DBLE) THEN
              NZERO=NZERO+1
            ELSE
              NELEM=NELEM+1
            ENDIF

            RSUM=RSUM+ABS(A(IJ))
            COL(ISC_A(IJ))=COL(ISC_A(IJ))+ABS(A(IJ))

            IF(ISC_A(IJ).EQ.I) THEN
              HAVE_DIAG=.TRUE.
              DIAG=ABS(A(IJ))
            ENDIF

            IF(IJ.GT.ISR_A(I)) THEN
              IF(ISC_A(IJ).EQ.IDX) THEN
                NREP=NREP+1
              ELSE IF(ISC_A(IJ).LT.IDX) THEN
                NUNSORT_ELEM=NUNSORT_ELEM+1
                UNSORTED=.TRUE.
              ENDIF
            ENDIF
            IDX=ISC_A(IJ)
          ENDDO

          IF(ISR_A(I+1)-ISR_A(I).LT.0) THEN
            NERR=NERR+1
          ELSE IF(ISR_A(I+1)-ISR_A(I).EQ.0) THEN
            NZROW=NZROW+1
          ELSE IF(RSUM.LE.EPS_DBLE) THEN
            NROWS=NROWS+1
          ENDIF

          IF(HAVE_DIAG) THEN
            IF(DIAG.LE.EPS_DBLE) NZDIAG=NZDIAG+1
          ELSE
            NEDIAG=NEDIAG+1
          ENDIF

          IF(UNSORTED) NUNSORT_ROW=NUNSORT_ROW+1

C         Calculate the diagonal dominance data
          RSUM=RSUM-DIAG*(1.0D0+EPS_DBLE)
          IF(RSUM.GT.EPS_DBLE) THEN
            RATIO=DIAG/RSUM
            NR=NR+1
            RATIO_AVE=RATIO_AVE+RATIO
          ELSE IF(DIAG.LE.EPS_DBLE) THEN
            RATIO=0.0D0
          ELSE
            RATIO=MAX_DBLE
          ENDIF
          RATIO_MIN=MIN(RATIO_MIN,RATIO)
          RATIO_MAX=MAX(RATIO_MAX,RATIO)
        ENDDO
C$OMP   END PARALLEL DO
        RATIO_AVE=RATIO_AVE/DBLE(NR)

C$OMP   PARALLEL DO PRIVATE(J), REDUCTION(+:NCOLS)
        DO J=1,N
          IF(COL(J).LE.EPS_DBLE) NCOLS=NCOLS+1
        ENDDO
C$OMP   END PARALLEL DO
        NPHYS=ISR_A(N+1)-1

      ELSE
         ERROR='>>Sparsity type not implemented'
         GOTO 9999
      ENDIF

C     Calculate fill ratios
      NTOTAL=N
      NTOTAL=NTOTAL**2
      PELEM=(DBLE(NELEM)/DBLE(NPHYS))*100.0D0
      PZERO=(DBLE(NZERO)/DBLE(NPHYS))*100.0D0
      PFILL=(DBLE(NPHYS)/DBLE(NTOTAL))*100.0D0

C     Reset diagonal dominance ratios in cases where there
C     are zeros on the diagonal (ick).
      IF(RATIO_MAX.GE.MAX_DBLE) THEN
        IMAX=0
        RATIO_MAX=1.0D0
      ELSE
        IMAX=1
      ENDIF
      IF(RATIO_MIN.GE.MAX_DBLE) THEN
        IMIN=0
        RATIO_MIN=1.0D0
      ELSE
        IMIN=1
      ENDIF
      IF(RATIO_AVE.GE.MAX_DBLE) THEN
        IAVE=0
        RATIO_AVE=1.0D0
      ELSE
        IAVE=1
      ENDIF

C     Summary
      WRITE(OP_STRING,7000) ' Total number of rows                  :',N
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7000) ' Number of rows having a zero norm     :',
     '  NROWS
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7000) ' Number of columns having a zero norm  :',
     '  NCOLS
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      IF(NERR.GT.0) THEN
        WRITE(OP_STRING,7000) ' Number of errors in row index         :'
     '    ,NERR
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ENDIF
      IF(SPARSE_A.NE.0) THEN
        WRITE(OP_STRING,7000) ' Number of repeated elements           :'
     '    ,NREP
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        WRITE(OP_STRING,7000) ' Number of unsorted rows               :'
     '    ,NUNSORT_ROW
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        WRITE(OP_STRING,7000) ' Number of unsorted elements           :'
     '    ,NUNSORT_ELEM
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        WRITE(OP_STRING,7000) ' Number of rows having no entries      :'
     '    ,NZROW
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
        WRITE(OP_STRING,7000) ' Number of rows with no diagonal entry :'
     '    ,NEDIAG
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ENDIF
      WRITE(OP_STRING,7000) ' Number of diagonals set to zero       :',
     '  NZDIAG
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      IF(RATIO_MIN.GE.1.0D0 .AND. NZDIAG+NEDIAG.EQ.0) THEN
        WRITE(OP_STRING,7300) ' Matrix is Diagonally Dominant'
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ELSE
        WRITE(OP_STRING,7300) ' Matrix is Not Diagonally Dominant'
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ENDIF
      WRITE(OP_STRING,7400) ' Maximum Diagonal Dominance            :',
     '  RATIO_MAX,':',IMAX
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7400) ' Minimum Diagonal Dominance            :',
     '  RATIO_MIN,':',IMIN
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7400) ' Mean Diagonal Dominance               :',
     '  RATIO_AVE,':',IAVE
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      WRITE(OP_STRING,7000) ' Number of nonzero elements            :',
     '  NELEM
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7000) ' Number of elements set to zero        :',
     '  NZERO
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7000) ' Total number of allocated matrix elem :',
     '  NPHYS
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7000) ' Total matrix size                     :',
     '  NTOTAL
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      WRITE(OP_STRING,7100) ' Number of nonzero elements            :',
     '  PELEM,'%'
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7100) ' Number of zeroed elements             :',
     '  PZERO,'%'
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,7100) ' Matrix fill ratio                     :',
     '  PFILL,'%'
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      WRITE(OP_STRING,'()')
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      CALL WRITES(IOOP,OP_STRING,ERROR,*9999)

      RETURN

 7000 FORMAT(A,1X,I18)
 7100 FORMAT(A,8X,F10.5,A)
 7200 FORMAT(A,8X,1P,E11.4)
 7300 FORMAT(A)
 7400 FORMAT(A,9X,1P,E8.1,A,I1)

 9999 CALL ERRORS('CHECK_MATRIX',ERROR)
      RETURN 1
      END


      SUBROUTINE FIX_MATRIX(A,LDA,N,SPARSE_A,ISC_A,ISR_A,ERROR,*)

C#### Subroutine: FIX_MATRIX
C###  Description:
C###    Fix broken arrays that have zero rows.
C###  Written by Stuart Norris 07/08/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER LDA,N,SPARSE_A,ISC_A(*),ISR_A(*)
      REAL*8 A(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,IJ,II,NFIX
      REAL*8 EPS_DBLE,SUM
      LOGICAL HAVE_DIAG
!     External routines
      REAL*8 DASUM,DLAMCH
      EXTERNAL DASUM,DLAMCH


      EPS_DBLE=DLAMCH('E')
      II=1

C     Non-sparse matricies
      IF(SPARSE_A.EQ.0) THEN

        NFIX=0
        DO I=1,N
          SUM=DASUM(N,A(I),LDA)

C         If the row sums to zero, set the diagonal to 1
          IF(SUM.LE.EPS_DBLE) THEN
            II=I+LDA*(I-1)
            A(II)=1.0D0
            NFIX=NFIX+1
          ENDIF
        ENDDO

C     Sparse matricies: CMISS compressed row
      ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN

        NFIX=0
        DO I=1,N
          HAVE_DIAG=.FALSE.

          SUM=0.0D0
          DO IJ=ISR_A(I),ISR_A(I+1)-1
            SUM=SUM+ABS(A(IJ))
            IF(ISC_A(IJ).EQ.I) THEN
              HAVE_DIAG=.TRUE.
              II=IJ
            ENDIF
          ENDDO

C         If the row sums to zero we want to set the diagonal to 1
          IF(SUM.LE.EPS_DBLE) THEN
C           If we have a zero diagonal element, set it to 1
            IF(HAVE_DIAG) THEN
              A(II)=1.0D0
              NFIX=NFIX+1

C           Otherwise shift another element to the diagonal and set it to 1
            ELSE IF(ISR_A(I+1).GT.ISR_A(I)) THEN
              II=ISR_A(I)
              DO IJ=ISR_A(I)+1,ISR_A(I+1)-1
                IF(ISC_A(IJ).LE.I) II=IJ
              ENDDO
              ISC_A(IJ)=I
              A(II)=1.0D0
              NFIX=NFIX+1

C           Here we have no elements on the row, so we fail
            ELSE
              ERROR='>>Have no entries on row'
              GOTO 9999
            ENDIF
          ENDIF
        ENDDO

      ELSE
         ERROR='>>Sparsity type not implemented'
         GOTO 9999
      ENDIF

      IF(NFIX.GT.0) THEN
        WRITE(OP_STRING,7000) ' Number of Rows Fixed = ',NFIX
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ELSE
        WRITE(OP_STRING,7100) ' No Rows Needed Fixing'
        CALL WRITES(IOOP,OP_STRING,ERROR,*9999)
      ENDIF

      RETURN

 7000 FORMAT(A,I18)
 7100 FORMAT(A)

 9999 CALL ERRORS('FIX_MATRIX',ERROR)
      RETURN 1
      END


      SUBROUTINE SOLV_FIX_BOUNDS(A,LDA,N,X,B,SPARSE_A,ISC_A,ISR_A,
     '  ERROR,*)

C#### Subroutine: SOLV_FIX_BOUNDS
C###  Description:
C###    Fix the boundary conditions for systems (usually collocated meshes)
C###    where the boundarys havn't been canceled out, resulting in a 
C###    non-symmetric system.
C###  Written by Stuart Norris 18/10/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER LDA,N,SPARSE_A,ISC_A(*),ISR_A(*)
      REAL*8 A(*),B(N),X(N)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,II,IJ
      REAL*8 EPS,SUM,AII
!     External routines
      INTEGER IDAMAX
      REAL*8 DASUM,DLAMCH
      EXTERNAL DASUM,IDAMAX,DLAMCH


      EPS=DLAMCH('E')

C     Non-sparse matricies
      IF(SPARSE_A.EQ.0) THEN

C$OMP   PARALLEL DO PRIVATE(I,II,AII,SUM), FIRSTPRIVATE(N,LDA)
        DO I=1,N
          SUM=DASUM(N,A(I),LDA)
          II=IDAMAX(N,A(I),LDA)
          AII=A(I+(II-1)*LDA)
          IF(SUM.GT.2.0D0*EPS .AND. ABS(SUM-ABS(AII)).LT.EPS) THEN
            X(II)=B(I)/AII
          ENDIF
        ENDDO
C$OMP   END PARALLEL DO

C     Sparse matricies: CMISS compressed row
      ELSE IF(SPARSE_A.EQ.1) THEN

C$OMP   PARALLEL DO PRIVATE(I,II,IJ,AII,SUM)
        DO I=1,N
          II=ISR_A(I)
          AII=A(II)
          SUM=ABS(AII)

          DO IJ=ISR_A(I)+1,ISR_A(I+1)-1
            SUM=SUM+ABS(A(IJ))
            IF(ABS(A(IJ)).GT.ABS(AII)) THEN
              II=IJ
              AII=A(IJ)
            ENDIF
          ENDDO

          IF(SUM.GT.2.0D0*EPS .AND. ABS(SUM-ABS(AII)).LT.EPS) THEN
            X(ISC_A(II))=B(I)/AII
          ENDIF
        ENDDO
C$OMP   END PARALLEL DO

      ELSE
         ERROR='>>Sparsity type not implemented'
         GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('SOLV_FIX_BOUNDS',ERROR)
      RETURN 1
      END


      SUBROUTINE GET_IJ_MAT(IJ,I,J,LDA,N,SPARSE_A,PIVOT_A,IPIVOT_A,
     '  ISC_A,ISR_A,ERROR,*)

C#### Subroutine: GET_IJ_MAT
C###  Description:
C###    Find the IJ location in a matrix, based on the matrix row/column info.
C###  Written by Stuart Norris 25/03/02

      IMPLICIT NONE
!     Parameter List
      INTEGER IJ,I,J,LDA,N,SPARSE_A,IPIVOT_A(*),ISC_A(*),ISR_A(*)
      CHARACTER ERROR*(*)
      LOGICAL PIVOT_A
!     Local Variables
      INTEGER KLO,KHI,MID


C     Non-sparse matricies
      IF(SPARSE_A.EQ.0) THEN
        IJ=I+(J-1)*LDA

C     Sparse matricies: CMISS compressed row
      ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
        IF(I.LT.1.OR.I.GT.N) THEN
          ERROR='>>Array coordinates outside range'
          GOTO 9999
        ENDIF
        DO IJ=ISR_A(I),ISR_A(I+1)-1
          IF(ISC_A(IJ).EQ.J) GOTO 100
        ENDDO
        IJ=0
 100    CONTINUE

C     Sparse matricies: sorted CMISS compressed row
C     Use a bisection search.
      ELSE IF(SPARSE_A.EQ.4) THEN
        IF(I.LT.1.OR.I.GT.N) THEN
          ERROR='>>Array coordinates outside range'
          GOTO 9999
        ENDIF
        KLO=ISR_A(I)
        KHI=ISR_A(I+1)
        MID=(KHI+KLO)/2
        DO WHILE(MID.GT.KLO)
          IF(ISC_A(MID).GT.J) THEN
            KHI=MID
          ELSE
            KLO=MID
          ENDIF
          MID=(KHI+KLO)/2
        ENDDO
        IF(ISC_A(KLO).EQ.J) THEN
          IJ=KLO
        ELSE
          IJ=0
        ENDIF

C     Other non supported format
      ELSE
        ERROR='>>Sparsity type not implemented'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('GET_IJ_MAT',ERROR)
      RETURN 1
      END


      SUBROUTINE CONVERT_SPARSE_5TO1(M,N,NZA,ISC_A,ISR_A,ERROR,*)

C#### Subroutine: CONVERT_SPARSE_5TO1
C###  Description:
C###    Convert array index from sorted Umfpack 2.2 Row-Column format
C###    to compressed-row format.
C###  Written by Stuart Norris 22/08/02

      IMPLICIT NONE
!     Parameter List
      INTEGER M,N,NZA,ISC_A(*),ISR_A(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,IJ,INEW


C     Generate ISR index
      ISR_A(1)=1
      I=1
      DO IJ=1,NZA
        INEW=ISC_A(IJ)
C       Spot start of new row
        IF(INEW.NE.I) THEN
C         We only deal with ordered rows
          IF(INEW.NE.I+1) THEN
            ERROR='>>Unordered row order'
            GOTO 9999
          ENDIF

          IF(INEW.GT.M .OR. INEW.LT.1) THEN
            ERROR='>>Row out of bounds'
            GOTO 9999
          ENDIF

          ISR_A(I+1)=IJ
          I=I+1
        ENDIF
      ENDDO
      ISR_A(M+1)=NZA+1

C     Shift the ISC index
      DO IJ=1,NZA
        ISC_A(IJ)=ISC_A(NZA+IJ)

        IF(ISC_A(IJ).GT.N .OR. ISC_A(IJ).LT.1) THEN
          ERROR='>>Column out of bounds'
          GOTO 9999
        ENDIF
      ENDDO
C     CALL DCOPY(NZA,ISC_A(NZA+1),1,ISC_A(1),1)

      RETURN

 9999 CALL ERRORS('CONVERT_SPARSE_5TO1',ERROR)
      RETURN 1
      END


      SUBROUTINE CALC_MAT_NORM(ANORM,A,LDA,N,SPARSE_A,ISC_A,ISR_A,
     '  NORMTYPE,ERROR,*)

C#### Subroutine: CALC_MAT_NORM
C###  Description:
C###    Calculates the infinity, first or second norms of a matrix,
C###    ||A||_\infty, ||A||_1 or ||A||_2. Used in determining the
C###    "scale" of a matrix, when considering convergance with 
C###    iterative solver.
C###  Written by Stuart Norris 21/03/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER LDA,N,SPARSE_A,ISC_A(*),ISR_A(*),NORMTYPE
      REAL*8 ANORM,A(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,IJ
      REAL*8 TMP,SUM,ASUM(N)
!     External functions
      REAL*8 DNRM2,DASUM,PDASUM
      EXTERNAL DNRM2,DASUM,PDASUM


      CALL ASSERT(NORMTYPE.GE.0.AND.NORMTYPE.LE.2,'>>Normtype not '
     '  //'suported',ERROR,*9999)
      CALL ASSERT(SPARSE_A.EQ.0 .OR. SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4,
     '  '>>Sparsity type not implemented',ERROR,*9999)

C     Infinity norm
      IF(NORMTYPE.EQ.0) THEN

C       Non-sparse matricies
        IF(SPARSE_A.EQ.0) THEN
          TMP=0.0D0
C$OMP     PARALLEL DO PRIVATE(I), FIRSTPRIVATE(N,LDA),REDUCTION(MAX:TMP)
          DO I=1,N
            TMP=MAX(TMP,DASUM(N,A(I),LDA))
          ENDDO
C$OMP     END PARALLEL DO
          ANORM=TMP

C       Sparse matricies: CMISS compressed row
        ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
          TMP=0.0D0
C$OMP     PARALLEL DO PRIVATE(I,IJ,SUM), REDUCTION(MAX:TMP)
          DO I=1,N
            SUM=0.0D0
            DO IJ=ISR_A(I),ISR_A(I+1)-1
              SUM=SUM+ABS(A(IJ))
            ENDDO
            TMP=MAX(TMP,SUM)
          ENDDO
C$OMP     END PARALLEL DO
          ANORM=TMP

        ELSE
          ERROR='>>Sparsity type not implemented'
          GOTO 9999
        ENDIF

C     First norm
      ELSE IF(NORMTYPE.EQ.1) THEN

C       Non-sparse matricies
        IF(SPARSE_A.EQ.0) THEN
          SUM=0.0D0
          DO I=1,N
            ANORM=MAX(ANORM,PDASUM(N,A((I-1)*LDA+1),1))
          ENDDO

C       Sparse matricies: CMISS compressed row
        ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
C$OMP     PARALLEL DO PRIVATE(I)
          DO I=1,N
            ASUM(I)=0.0D0
          ENDDO
C$OMP     END PARALLEL DO

C         Will not parallelise with OpenMP
          DO I=1,N
            DO IJ=ISR_A(I),ISR_A(I+1)-1
              ASUM(ISC_A(IJ))=ASUM(ISC_A(IJ))+ABS(A(IJ))
            ENDDO
          ENDDO

          TMP=0.0D0
C$OMP     PARALLEL DO PRIVATE(I), REDUCTION(MAX:TMP)
          DO I=1,N
            TMP=MAX(TMP,ASUM(I))
          ENDDO
C$OMP     END PARALLEL DO
          ANORM=TMP

        ELSE
          ERROR='>>Sparsity type not implemented'
          GOTO 9999
        ENDIF

C     Second norm
      ELSE IF(NORMTYPE.EQ.2) THEN

C       Non-sparse matricies
        IF(SPARSE_A.EQ.0) THEN
          SUM=0.0D0
C$OMP     PARALLEL DO PRIVATE(I,IJ), FIRSTPRIVATE(N,LDA)REDUCTION(+:SUM)
          DO I=1,N
            SUM=SUM+DNRM2(N,A(I),LDA)**2
          ENDDO
C$OMP     END PARALLEL DO
          ANORM=SQRT(SUM)

C       Sparse matricies: CMISS compressed row
        ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
          SUM=0.0D0
C$OMP     PARALLEL DO PRIVATE(I,IJ) REDUCTION(+:SUM)
          DO I=1,N
            DO IJ=ISR_A(I),ISR_A(I+1)-1
              SUM=SUM+A(IJ)**2
            ENDDO
          ENDDO
C$OMP     END PARALLEL DO
          ANORM=SQRT(SUM)

        ELSE
          ERROR='>>Sparsity type not implemented'
          GOTO 9999
        ENDIF

      ELSE
        WRITE(ERROR,'(A,I10,A)') '>>Normtype',NORMTYPE,' not supported'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('CALC_MAT_NORM',ERROR)
      RETURN 1
      END


      SUBROUTINE CALC_VEC_NORM(BNORM,B,N,NORMTYPE,ERROR,*)

C#### Subroutine: CALC_VEC_NORM
C###  Description:
C###    Calculates the infinity, first or second norms of a vector b,
C###    ||b||_\infty, ||b||_1 or ||b||_2. Used in determining the
C###    "scale" of a vector, when considering convergance with 
C###    iterative solver.
C###  Written by Stuart Norris 21/03/02

      IMPLICIT NONE
      INCLUDE 'cbdi02.cmn'
!     Parameter List
      INTEGER N,NORMTYPE
      REAL*8 BNORM,B(*)
      CHARACTER ERROR*(*)
!     Local Variables
!     External functions
      REAL*8 PDAMAX,PDASUM,PDNRM2
      EXTERNAL PDAMAX,PDASUM,PDNRM2


      CALL ASSERT(NORMTYPE.GE.0 .AND. NORMTYPE.LE.2,'>>Normtype not '
     '  //'suported',ERROR,*9999)

C     Infinity norm
      IF(NORMTYPE.EQ.0) THEN
        BNORM=PDAMAX(N,B,1)

C     First norm
      ELSE IF(NORMTYPE.EQ.1) THEN
        BNORM=PDASUM(N,B,1)

C     Second norm
      ELSE IF(NORMTYPE.EQ.2) THEN
        BNORM=PDNRM2(N,B,1)

      ELSE
        WRITE(ERROR,'(A,I10,A)') '>>Normtype',NORMTYPE,' not supported'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('CALC_VEC_NORM',ERROR)
      RETURN 1
      END


      SUBROUTINE CALC_RESIDUAL(A,LDA,N,X,B,R,SPARSE_A,ISC_A,ISR_A,
     '  ERROR,*)

C#### Subroutine: CALC_RESIDUAL
C###  Description:
C###    CALC_RESIDUAL calculates the residule of a system of equations,
C###          r = b - A x
C###  Written by Stuart Norris 26/02/02

      IMPLICIT NONE
!     Parameter List
      INTEGER ISC_A(*),ISR_A(*),LDA,N,SPARSE_A
      REAL*8 A(*),X(*),B(*),R(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,IJ
      REAL*8 SUM
!     Functions
      REAL*8 DDOT
      EXTERNAL PDCOPY,DDOT,DGEMV


C     Dense systems
      IF(SPARSE_A.EQ.0) THEN
CC$OMP  PARALLEL DO PRIVATE(I,J,IJ,SUM)
CC      DO I=1,N
CC        R(I)=B(I)-DDOT(N,A(I),LDA,X,1)
CC      ENDDO
CC$OMP  END PARALLEL DO
        CALL PDCOPY(N,B,1,R,1)
        CALL DGEMV('NOTRANSPOSE',N,N,-1.0D0,A,LDA,X,1,1.0D0,R,1)

C     Compressed row storage
      ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
C$OMP   PARALLEL DO PRIVATE(I,IJ,SUM)
        DO I=1,N
          SUM=0.0D0
          DO IJ=ISR_A(I),ISR_A(I+1)-1
            SUM=SUM+A(IJ)*X(ISC_A(IJ))
          ENDDO
          R(I)=B(I)-SUM
        ENDDO
C$OMP   END PARALLEL DO
      ELSE
        ERROR='>>Sparsity type not implemented'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('CALC_RESIDUAL',ERROR)
      RETURN 1
      END


      SUBROUTINE MATRIX_MULT(A,LDA,N,X,B,SPARSE_A,ISC_A,ISR_A,ERROR,*)

C#### Subroutine: MATRIX_MULT
C###  Description:
C###    MATRIX_MULT calculates the matrix-vector multipication,
C###          b = A x
C###  Written by Stuart Norris 26/02/02

      IMPLICIT NONE
!     Parameter List
      INTEGER ISC_A(*),ISR_A(*),LDA,N,SPARSE_A
      REAL*8 A(*),X(*),B(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,IJ
      REAL*8 SUM
!     Functions
      REAL*8 DDOT
      EXTERNAL DDOT,DGEMV


C     Dense systems
      IF(SPARSE_A.EQ.0) THEN
CC$OMP  PARALLEL DO PRIVATE(I,J,IJ,SUM)
CC      DO I=1,N
CC        B(I)=DDOT(N,A(I),LDA,X,1)
CC      ENDDO
CC$OMP  END PARALLEL DO
        CALL DGEMV('NOTRANSPOSE',N,N,1.0D0,A,LDA,X,1,0.0D0,B,1)

C     Compressed row storage
      ELSE IF(SPARSE_A.EQ.1 .OR. SPARSE_A.EQ.4) THEN
C$OMP   PARALLEL DO PRIVATE(I,IJ,SUM)
        DO I=1,N
          SUM=0.0D0
          DO IJ=ISR_A(I),ISR_A(I+1)-1
            SUM=SUM+A(IJ)*X(ISC_A(IJ))
          ENDDO
          B(I)=SUM
        ENDDO
C$OMP   END PARALLEL DO

      ELSE
        ERROR='>>Sparsity type not implemented'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('MATRIX_MULT',ERROR)
      RETURN 1
      END


      SUBROUTINE MATRIX_COPY(A,LDA,B,LDB,N,SPARSE_A,ISC_A,ISR_A,ISC_B,
     '  ISR_B,ERROR,*)

C#### Subroutine: MATRIX_COPY
C###  Description:
C###    MATRIX_COPY copies a matrix enforcing the OMP data distribution that
C###    our iterative solvers desire.
C###  Written by Stuart Norris 22/10/02

      IMPLICIT NONE
!     Parameter List
      INTEGER ISC_A(*),ISR_A(*),ISC_B(*),ISR_B(*),LDA,LDB,N,SPARSE_A
      REAL*8 A(*),B(*)
      CHARACTER ERROR*(*)
!     Local Variables
      INTEGER I,J,IJ,IK
!     Functions
      EXTERNAL DCOPY


C     Dense systems
      IF(SPARSE_A.EQ.0) THEN
C$OMP   PARALLEL DO PRIVATE(J,IJ,IK), FIRSTPRIVATE(N)
        DO J=1,N
          IJ=1+(J-1)*LDA
          IK=1+(J-1)*LDB
          CALL DCOPY(N,A(IJ),1,B(IK),1)
        ENDDO
C$OMP   END PARALLEL DO

C     Compressed row storage
      ELSE IF(SPARSE_A.EQ.1) THEN
C$OMP   PARALLEL DO PRIVATE(I,IJ)
        DO I=1,N
          ISR_B(I)=ISR_A(I)
          DO IJ=ISR_A(I),ISR_A(I+1)-1
            B(IJ)=A(IJ)
            ISC_B(IJ)=ISC_A(IJ)
          ENDDO
        ENDDO
C$OMP   END PARALLEL DO
        ISR_B(N+1)=ISR_A(N+1)

      ELSE
        ERROR='>>Sparsity type not implemented'
        GOTO 9999
      ENDIF

      RETURN

 9999 CALL ERRORS('MATRIX_COPY',ERROR)
      RETURN 1
      END
