"#*******************************************************************************\n"
"#FILE : Perl_cmiss.pm\n"
"#\n"
"#LAST MODIFIED : 9 March 2001\n"
"#\n"
"#DESCRIPTION :\n"
"#With perl_interpreter.c provides an interface between cmiss and a \n"
"#Perl interpreter.\n"
"#===============================================================================\n"
"\n"
"package Perl_cmiss;\n"
"\n"
"$VERSION = '0.01';\n"
"bootstrap Perl_cmiss $VERSION;\n"
"\n"
"# Preloaded methods go here.\n"
"\n"
"#Using a hash so that the strategy for action could be placed with\n"
"#the word.  For now only one action.\n"
"my %keywords;\n"
"\n"
"my @command_list = ();\n"
"my $block_count = 0;\n"
"my $block_required = 0;\n"
"my $echo_commands = 0;\n"
"my $echo_prompt = \"\";\n"
"my $cmiss_debug = 0;\n"
"# Try to use Config.pm but only print a failure message once\n"
"$use_config = 1;\n"
"\n"
"sub set_INC_for_platform ($)\n"
"  {\n"
"	# Call this if the perl interpreter does not match the modules on the\n"
"	# local system (e.g. it is a built-in interpreter).\n"
"    my ($abi_env) = @_;\n"
"\n"
"    my $perlinc;\n"
"	my ($module_perl_version,$module_numeric_version);# perl module versions\n"
"\n"
"	# Run the local perl to get its version and @INC so we can use its\n"
"	# modules.\n"
"\n"
"	# Default is first perl in path:\n"
"	my $perl = 'perl';\n"
"	# see if an environment variable specifies which local perl.\n"
"	foreach my $varname (\"CMISS${abi_env}_PERL\",\"CMISS_PERL\")\n"
"	  {\n"
"		if( exists $ENV{$varname} )\n"
"		  {\n"
"			$perl = $ENV{$varname};\n"
"			last;\n"
"		  }\n"
"	  }\n"
"	# fork and catch STDOUT from the child.\n"
"	local *PERLOUT;\n"
"	unless( defined( my $pid = open PERLOUT, '-|' ) )\n"
"	  {\n"
"		print STDERR \"$^X: fork failed: $!\\n\";\n"
"	  }\n"
"	elsif( ! $pid ) #child\n"
"	  {\n"
"		exec $perl, '-e',\n"
"		  'print join \":\", $^V ? sprintf(\"v%vd\",$^V) : \"undef\", $], @INC'\n"
"		  or exit $!;\n"
"	  }\n"
"	else # parent\n"
"	  {\n"
"		my $perlout = <PERLOUT>;\n"
"		# check child completed successfully\n"
"		unless( close PERLOUT )\n"
"		  {\n"
"			$! = $? >> 8;\n"
"			print STDERR \"$^X: exec $perl failed: $!\\n\";\n"
"			$use_config = 0;\n"
"		  }\n"
"		else\n"
"		  {\n"
"			# perl has given us its version include list.\n"
"			($module_perl_version,$module_numeric_version,@INC) =\n"
"			  split /:/,$perlout;\n"
"		  }\n"
"	  }\n"
"\n"
"	# See if an environment variable is set to override @INC.\n"
"    foreach my $varname (\"CMISS${abi_env}_PERLINC\",\"CMISS_PERLINC\")\n"
"	  {\n"
"		if( exists $ENV{$varname} )\n"
"		  {\n"
"			@INC = split /:/,$ENV{$varname};\n"
"			last;\n"
"		  }\n"
"      }\n"
"\n"
"	# Dynaloader.pm uses Config.pm.\n"
"\n"
"	# Config.pm checks with the version of the interpreter.  We can lie about\n"
"	# our version so that this check passes.  Do this here so that require\n"
"	# Config works seemlessly elsewhere.\n"
"	# Should we check binary compatibility first?\n"
"\n"
"	if( defined $module_perl_version )\n"
"	  {\n"
"		{\n"
"		  # Convert version to a version literal for $^V\n"
"		  local $^V = eval $module_perl_version;\n"
"		  local $] = $module_numeric_version;\n"
"		  eval { require Config };\n"
"		}\n"
"\n"
"		if ( $@ )\n"
"		  {\n"
"			warn $@;\n"
"			$use_config = 0;\n"
"		  }\n"
"# 		else\n"
"# 		  {\n"
"		    # Now that we have Config, it would be an easy and good time to\n"
"			# check that we are binary compatible.  We could even pretend to\n"
"			# unrequire Config if we are not.\n"
"# 		  }\n"
"	  }\n"
"  }\n"
"\n"
"sub add_cmiss_perl_to_INC\n"
"  {\n"
"	{\n"
"	  #By not using \"use\" we can avoid the BEGIN and therefore the $use_config\n"
"	  #variable will be in the correct scope.  Because of this the automatic imports\n"
"	  #will not happen, so below we just use the qualified name for the Config hash.\n"
"	  eval { require Config };\n"
"	  if ( $@ )\n"
"	  {\n"
"		warn $@;\n"
"		$use_config = 0;\n"
"	  }\n"
"	}\n"
"\n"
"    my ($abi_env, $perl_version_archname) = @_;\n"
"\n"
"	my @path_list;\n"
"\n"
"	#Check the environment variables which specify this lib\n"
"    foreach my $varname (\"CMISS${abi_env}_PERLLIB\",\"CMISS_PERLLIB\")\n"
"	{\n"
"	  if ( exists $ENV{$varname} )\n"
"	 {\n"
"		my @env_list = split (':', $ENV{$varname});\n"
"		if ( $use_config )\n"
"		{\n"
"		  #Add in a version/archname specific derivative of any paths if they exist\n"
"		  # !!! Should use inc_version_list here (or just use lib.pm)\n"
"		  # or even choose our own old versions.\n"
"		  @path_list = (@env_list,\n"
"			 grep { -d $_ } map { \"$_/$Config::Config{version}/$Config::Config{archname}\" } @env_list);\n"
"		}\n"
"		last;\n"
"	  }\n"
"    }\n"
"	# If no CMISS*_PERLLIB variable is set then see if there is a CMISS_ROOT version\n"
"	if (! @path_list)\n"
"	{\n"
"	  if (exists $ENV{CMISS_ROOT})\n"
"	  {\n"
"		my $cmissroot_perl_lib = \"$ENV{CMISS_ROOT}/cmiss_perl/lib\";\n"
"		my $try_compiled_version = 1;\n"
"		@path_list = ();\n"
"		if (-d $cmissroot_perl_lib)\n"
"		{\n"
"		  push @path_list, $cmissroot_perl_lib;\n"
"		}\n"
"		if ( $use_config )\n"
"		{\n"
"		  my $cmissroot_perl_lib_arch = \"$ENV{CMISS_ROOT}/cmiss_perl/lib/$Config::Config{version}/$Config::Config{archname}\";\n"
"		  if (-d $cmissroot_perl_lib_arch)\n"
"		  {\n"
"			push @path_list, $cmissroot_perl_lib_arch;\n"
"			$try_compiled_version = 0;\n"
"		  }\n"
"		}\n"
"		if ($try_compiled_version)\n"
"		{\n"
"		  #If a directory matching the perl executable is not found, try one matching what the perl interpreter was compiled with.\n"
"		  my $cmissroot_perl_lib_arch = \"$ENV{CMISS_ROOT}/cmiss_perl/lib/$perl_version_archname\";\n"
"		  if (-d $cmissroot_perl_lib_arch)\n"
"		  {\n"
"			push @path_list, $cmissroot_perl_lib_arch;\n"
"		  }\n"
"		}\n"
"	  }\n"
"	}\n"
"	# If a CMISS_PERLLIB has been found prepend it to the path.\n"
"	if (@path_list)\n"
"	{\n"
"	  unshift @INC, @path_list;\n"
"	}\n"
" }\n"
"\n"
"sub register_keyword\n"
"  {\n"
"	 my $word = shift;\n"
"\n"
"	 #print \\\"register $word\\\\n\\\";\n"
"\n"
"	 $keywords{$word} = 1;\n"
"  }\n"
"\n"
"sub get_keywords_hash_reference\n"
"  {\n"
"	return \\%keywords;\n"
"  }\n"
"\n"
"sub call_command\n"
"  {\n"
"	 local $command = shift;\n"
"	 {\n"
"		package cmiss;\n"
"		*{cmiss::cmiss} = \\&{Perl_cmiss::cmiss};\n"
"		# Catch all warnings as errors */\n"
"		local $SIG{__WARN__} = sub { die $_[0] };\n"
"		eval ($Perl_cmiss::command);\n"
"	 }\n"
"  }\n"
"\n"
"sub cmiss_array\n"
"  {\n"
"	 my $command = \"\";\n"
"	 my $token2;\n"
"	 my $ref_type;\n"
"	 my $token;\n"
"	 my $subtoken;\n"
"	 my $first;\n"
"	 my $return_code;\n"
"\n"
"	 for $token (@_)\n"
"		{\n"
"		  if (! defined $token)\n"
"		  {\n"
"			 print (\"Undefined variable referenced in command\\n\");\n"
"			 return (0);\n"
"		  }\n"
"		  $ref_type = ref $token;\n"
"		  if ($token =~ /^[\\s;]+$/)\n"
"			 {\n"
"				#This is just a delimiter\n"
"				$command = $command . $token;\n"
"			 }\n"
"		  elsif (\"ARRAY\" eq $ref_type)\n"
"			 {\n"
"				$first = 1;\n"
"				for $subtoken (@{$token})\n"
"				  {\n"
"					if (! defined $subtoken)\n"
"					  {\n"
"						print (\"Undefined variable referenced in command\\n\");\n"
"						return(0);\n"
"					  }\n"
"					 if ($first)\n"
"						{\n"
"						  $first = 0;\n"
"						}\n"
"					 else\n"
"						{\n"
"						  $command = $command . \",\";\n"
"						}\n"
"					 if ($subtoken =~ /[\\s;]+/)\n"
"						{\n"
"						  $token2 = $subtoken;\n"
"						  #These delimiters need to be quoted and therefore the quotes and \n"
"						  #escape characters contained within must be escaped.\n"
"						  $token2 =~ s/\\\\/\\\\\\\\/g;\n"
"						  $token2 =~ s/\\\"/\\\\\\\"/g;\n"
"						  $command = $command . \"\\\"$token2\\\"\";\n"
"						}\n"
"					 else\n"
"						{\n"
"						  $command = $command . $subtoken;\n"
"						}\n"
"				  }\n"
"			 }\n"
"		  elsif ($token =~ /[\\s;]+/)\n"
"			 {\n"
"				$token2 = $token;\n"
"				#These delimiters need to be quoted and therefore the quotes and \n"
"				#escape characters contained within must be escaped.\n"
"				$token2 =~ s/\\\\/\\\\\\\\/g;\n"
"				$token2 =~ s/\\\"/\\\\\\\"/g;\n"
"				$command = $command . \"\\\"$token2\\\"\";\n"
"			 }\n"
"		  else\n"
"			 {\n"
"				#This is just a plain word\n"
"				$command = $command . $token;\n"
"			 }\n"
"		}\n"
"\n"
"	 if ($cmiss_debug)\n"
"		{\n"
"		  print \"Perl_cmiss::cmiss_array final: $command\\n\";\n"
"		}\n"
"	 {\n"
"		package cmiss;\n"
"		$return_code = Perl_cmiss::cmiss($command);\n"
"	 }\n"
"	 if ($cmiss_debug)\n"
"		{\n"
"		  print \"Perl_cmiss::cmiss_array cmiss return_code $return_code\\n\";\n"
"		}\n"
"	 return ($return_code);\n"
"  }\n"
"\n"
"sub execute_command\n"
"  {\n"
"	 my $command = shift;\n"
"	 my $command2 = $command;\n"
"	 $command2 =~ s%'%\\\\'%g;\n"
"	 $command2 = \"print '$echo_prompt$command2' . \\\"\\\\n\\\";\";\n"
"	 my $token = \"\";\n"
"	 my $part_token;\n"
"	 my $token2;\n"
"	 my $lc_token;\n"
"	 my $match_string = join (\"|\", keys %keywords);\n"
"#	 my @tokens = &parse_line('\\\\s*[\\\\{\\\\}\\\\(\\\\)]\\\\s*', \\\"delimiters\\\", $command);\n"
"#	 my @tokens; push (@tokens, $command);\n"
"	 my @tokens = ();\n"
"	 my $extracted;\n"
"	 my $lc_command;\n"
"	 my $continue;\n"
"	 my $reduced_command;\n"
"	 my $print_command_after = 0;\n"
"	 my $is_perl_token;\n"
"	 my $simple_perl;\n"
"\n"
"	 $simple_perl = 0;\n"
"	 while ($command ne \"\")\n"
"		{\n"
"		  $lc_command = lc ($command);\n"
"		  if ($cmiss_debug)\n"
"			 {\n"
"				print \"$command   \";\n"
"			 }\n"
"		  if ($command =~ s%^(\\s+)%%)\n"
"			 {\n"
"				if ($cmiss_debug)\n"
"				  {\n"
"					 print \"space: $1\\n\";\n"
"				  }\n"
"				$token = $token . $1;\n"
"			 }\n"
"		  elsif ($command =~ s%^(#.*)%%)\n"
"			 {\n"
"			  if ($cmiss_debug)\n"
"			    {\n"
"					print \"comment: $1\\n\";\n"
"				 }\n"
"			  if ($simple_perl && (!$block_required) && (! ($token =~ m/;\\s*$/)))\n"
"			  {\n"
"				 $token = $token . \";\";\n"
"			  }\n"
"			  if ($token ne \"\")\n"
"			  {\n"
"				 push(@tokens, $token);\n"
"			  }\n"
"			  $token = \"\";\n"
"			 }\n"
"		  else\n"
"			 {\n"
"				$simple_perl = 0;\n"
"				if ($command =~ s%^({)%%)\n"
"				  {\n"
"					 if ($cmiss_debug)\n"
"						{\n"
"						  print \"open bracket: $1\\n\";\n"
"						}\n"
"					 if ($token ne \"\")\n"
"						{\n"
"						  push(@tokens, $token);\n"
"						}\n"
"					 $block_required = 0;\n"
"					 $block_count++;\n"
"					 $print_command_after = 1;\n"
"					 $token = \"\";\n"
"					 push(@tokens, $1);\n"
"				  }\n"
"				elsif ($command =~ s%^(})%%)\n"
"				  {\n"
"					 if ($cmiss_debug)\n"
"						{\n"
"						  print \"close bracket: $1\\n\";\n"
"						}\n"
"					 if ($token ne \"\")\n"
"						{\n"
"						  push(@tokens, $token);\n"
"						}\n"
"					 if ($block_count > 0)\n"
"						{\n"
"						  $block_count--;\n"
"						}\n"
"					 $print_command_after = 0;\n"
"					 $token = \"\";\n"
"					 push(@tokens, $1);\n"
"				  }\n"
"				elsif (($token =~ m/(^|\\W)$/) && \n"
"				  ($command =~ s%^(if|while|unless|until|for|foreach|elsif|else|continue|sub)\\b%%))\n"
"				  {\n"
"					 if ($cmiss_debug)\n"
"						{\n"
"						  print \"control keyword: $1\\n\";\n"
"						}\n"
"					 $token = $token . $1;\n"
"					 $block_required = 1;\n"
"				  }\n"
"				elsif( $token =~ m/^\\s*$/ &&\n"
"					   $lc_command =~ m/^(itp(\\s+(ass\\w*)(?:\\s+blo\\w*(?:\\s+clo\\w*)?)?|\\s+(set)(\\s+(ech\\w*)|\\s+(deb\\w*))?)?\\s+)?\\?+/ )\n"
"			    {\n"
"				    my $itp = defined $1;\n"
"					my $second_word = defined $2;\n"
"					my $assert = defined $3;\n"
"					my $set = defined $4;\n"
"					my $third_word = defined $5;\n"
"					my $echo = defined $6;\n"
"					my $debug = defined $7;\n"
"\n"
"					print \"itp\\n\";\n"
"					if ( ! $second_word || $assert ) {\n"
"						print \"  assert blocks closed\\n\";\n"
"					}\n"
"					if ( ! $second_word || $set ) {\n"
"						print \"  set\\n\";\n"
"						if ( ! $third_word || $echo ) {\n"
"							print \"    echo\\n\";\n"
"							print \"      <on>\\n\";\n"
"							print \"      <off>\\n\";\n"
"							print \"      <prompt PROMPT_STRING>\\n\";\n"
"						}\n"
"						if ( ! $third_word || $debug ) {\n"
"							print \"    debug\\n\";\n"
"							print \"      <on>\\n\";\n"
"							print \"      <off>\\n\";\n"
"						}\n"
"					}\n"
"					if ( ! $itp ) {\n"
"						#Call Cmiss with the help command\n"
"						$token .= \"Perl_cmiss::cmiss_array(\\\"$lc_command\\\")\";\n"
"						push(@tokens, $token);\n"
"						$token = \"\";\n"
"					}\n"
"					$command =~ s/^([^}#]*)//;\n"
"					if ( $cmiss_debug ) {\n"
"						print \"itp?: $1\\n\";\n"
"					}\n"
"				}\n"
"				elsif ($lc_command =~ m/^itp/)\n"
"				  {\n"
"					 if ($lc_command =~ m/^itp\\s+ass\\w*\\s+blo\\w*\\s+clo\\w*/)\n"
"						{\n"
"						  if ($block_required || $block_count)\n"
"							 {\n"
"								$block_required = 0;\n"
"								$block_count = 0;\n"
"								@command_list = ();\n"
"								die (\"itp assert blocks closed failed\\n\");\n"
"							 }\n"
"						}\n"
"					 elsif ($lc_command =~ m/^itp\\s+set\\s+echo\\s*(\\w*)\\s*(?:[\\\"\\']([^\\\"\\']*)[\\\"\\']|([^\\\"\\']+\\S*)|)/)\n"
"						{\n"
"						  my $first_word = $1;\n"
"						  my $second_word = $2 ? $2 : $3;\n"
"						  if ($first_word =~ m/on/)\n"
"							 {\n"
"								$echo_commands = 1;\n"
"							 }\n"
"						  elsif ($first_word =~ m/off/)\n"
"							 {\n"
"								$echo_commands = 0;\n"
"							 }\n"
"						  elsif ($first_word =~ m/pro/)\n"
"							 {\n"
"								$echo_prompt = $second_word;\n"
"							 }\n"
"						  else\n"
"							 {\n"
"								$echo_commands = ! $echo_commands;\n"
"							 }\n"
"						}\n"
"					 elsif ($lc_command =~ m/^itp\\s+set\\s+debug\\s*(\\w*)/)\n"
"						{\n"
"						  if ($1 =~ m/on/)\n"
"							 {\n"
"								$cmiss_debug = 1;\n"
"							 }\n"
"						  elsif ($1 =~ m/off/)\n"
"							 {\n"
"								$cmiss_debug = 0;\n"
"							 }\n"
"						  else\n"
"							 {\n"
"								$cmiss_debug = ! $cmiss_debug;\n"
"							 }\n"
"						}\n"
"					 else\n"
"						{\n"
"						  die (\"Unknown itp environment command\\n\");\n"
"						}\n"
"					 $command =~ s/^([^}#]*)//;\n"
"					 if ($cmiss_debug)\n"
"						{\n"
"						  print \"itp: $1\\n\";\n"
"						}\n"
"				  }\n"
"				else\n"
"				  {\n"
"					 $continue = 1;\n"
"					 if ($token =~ m/^\\s*$/)\n"
"						{\n"
"						  if (($lc_command =~ m/^(?:$match_string)\\b/)\n"
"								|| ($lc_command =~ m/^q$/))\n"
"							 {\n"
"								$token = $token . \"(Perl_cmiss::cmiss_array(\";\n"
"								$part_token = \"\";\n"
"								$token2 = \"\";\n"
"								$is_perl_token = 1;\n"
"								$is_simple_token = 1;\n"
"								while (($command ne \"\") && !($command =~ m/(^[}	#])/))\n"
"								  {\n"
"									 if ($cmiss_debug)\n"
"										{\n"
"										  print \"cmiss $command   \";\n"
"										}\n"
"									 if ($command =~ s%^([\\s;]+)%%)\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											 {\n"
"												print \"cmiss space: $1\\n\";\n"
"											 }\n"
"										  if (!$is_simple_token && $is_perl_token)\n"
"											 {\n"
"												# Let Perl parse this into a string array\n"
"												$token = $token . \"[$part_token],\\\"$1\\\",\";\n"
"											 }\n"
"										  else\n"
"											 {\n"
"												# Add it as a string \n"
"												# Escape \\\\ and \" characters\n"
"												$part_token =~ s/\\\\/\\\\\\\\/g;\n"
"												$part_token =~ s/\\\"/\\\\\\\"/g;\n"
"												$token = $token . \"\\\"$part_token\\\",\\\"$1\\\",\";\n"
"											 }\n"
"										  $token2 = $token2 . $part_token . $1;\n"
"										  $is_perl_token = 1;\n"
"										  $is_simple_token = 1;\n"
"										  $part_token = \"\";\n"
"										}\n"
"									 elsif (($part_token eq \"\") && ($command =~ s%^(\\?+|[\\-]?[.,0-9:]+)%%))\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											 {\n"
"												print \"cmiss number/operator: $1\\n\";\n"
"											 }\n"
"										  $part_token = $part_token . $1;\n"
"										}\n"
"									 elsif ($command =~ s%^([.,0-9:]+)%%)\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											 {\n"
"												print \"cmiss number/operator: $1\\n\";\n"
"											 }\n"
"										  $part_token = $part_token . $1;\n"
"										}\n"
"									 elsif ($command =~ s%^([+\\-*=/\\\\<>!()?])%%)\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											 {\n"
"												print \"cmiss perl number/operator: $1\\n\";\n"
"											 }\n"
"										  $part_token = $part_token . $1;\n"
"										  $is_simple_token = 0;\n"
"										}\n"
"									 elsif ($command =~ s%^(\\w+\\()%%)\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											 {\n"
"												print \"cmiss function: $1\\n\";\n"
"											 }\n"
"										  $part_token = $part_token . $1;\n"
"										  $is_simple_token = 0;\n"
"										}\n"
"									 else\n"
"										{\n"
"										  $is_simple_token = 0;\n"
"										  ($extracted, $reduced_command) = \n"
"											 Perl_cmiss::Text::Balanced::extract_variable($command);\n"
"										  if ($extracted)\n"
"											 {\n"
"												$command = $reduced_command;\n"
"												$part_token = $part_token . $extracted;\n"
"												if ($cmiss_debug)\n"
"												  {\n"
"													 print \"cmiss variable: $extracted\\n\";\n"
"												  }\n"
"											 }\n"
"										  else\n"
"											 {\n"
"												($extracted, $reduced_command) =\n"
"												  Perl_cmiss::Text::Balanced::extract_delimited($command, '\\'\"`');\n"
"												if ($extracted)\n"
"												  {\n"
"													 $command = $reduced_command;\n"
"													 #Escape \" and \\ characters except for the start and end ones\n"
"													 #$extracted =~ s/(?<=.)\\\\(?=.)/\\\\\\\\/g;\n"
"													 #$extracted =~ s/(?<=.)\\\"(?=.)/\\\\\\\"/g;\n"
"													 $part_token = $part_token . $extracted;\n"
"													 if ($cmiss_debug)\n"
"														{\n"
"														  print \"cmiss delimited: $extracted\\n\";\n"
"														}\n"
"												  }\n"
"												else\n"
"												  {\n"
"													 if ($cmiss_debug)\n"
"														{\n"
"														  print \"cmiss character: \".substr($command, 0, 1).\"\\n\";\n"
"														}\n"
"													 $part_token = $part_token . substr($command, 0, 1);\n"
"													 $command = substr($command, 1);\n"
"													 $is_perl_token = 0;\n"
"												  }\n"
"											 }\n"
"										}\n"
"								  }\n"
"							  $token2 = $token2 . $part_token;\n"
"							  $token2 =~ s/\\\\/\\\\\\\\/g;\n"
"							  $token2 =~ s/\\\"/\\\\\\\"/g;\n"
"							  $token2 =~ s/\\$/\\\\\\$/g;\n"
"							  $token2 =~ s/\\@/\\\\\\@/g;\n"
"#							  if ($cmiss_debug)\n"
"#							    {\n"
"#									print \"token2 $token2\\n\";\n"
"#								 }\n"
"							  if (!$is_simple_token && $is_perl_token)\n"
"								 {\n"
"									# Let Perl parse this into a string array\n"
"									$token = $token . \"[$part_token])) || die(\\\"Error in cmiss command \\\\\\\"$token2\\\\\\\".\\\\n\\\");\";\n"
"								 }\n"
"							  else\n"
"								 {\n"
"									# Add it as a string \n"
"									# Escape \\\\ and \" characters\n"
"									$part_token =~ s/\\\\/\\\\\\\\/g;\n"
"									$part_token =~ s/\\\"/\\\\\\\"/g;\n"
"									$token = $token . \"\\\"$part_token\\\")) || die(\\\"Error in cmiss command \\\\\\\"$token2\\\\\\\".\\\\n\\\");\";\n"
"								 }\n"
"							  if ($cmiss_debug)\n"
"								 {\n"
"									print \"cmiss: $token\\n\";\n"
"								 }\n"
"							  push(@tokens, $token);\n"
"							  $token = \"\";\n"
"						     $continue = 0;\n"
"                    }\n"
"				    }\n"
"				  if ($continue)\n"
"					 {\n"
"						$simple_perl = 1;\n"
"						if ($command =~ s/^(\\d+)\\s*\\.\\.\\s*(\\d+)\\s*:\\s*(\\d+)//)\n"
"						  {\n"
"							 my $remainder_start = $1 % $3;\n"
"							 my $remainder_finish = ($2 - $remainder_start) % $3;\n"
"							 my $list_start = ($1 - $remainder_start) / $3;\n"
"							 my $list_finish = ($2 - $remainder_start - $remainder_finish)/ $3;\n"
"							 my $new_list_operator = \"(map {\\$_ * $3 + $remainder_start} $list_start..$list_finish)\";\n"
"							 $token = $token . $new_list_operator;\n"
"							 if ($cmiss_debug)\n"
"								{\n"
"								  print \"step sequence: $new_list_operator\\n\";\n"
"								}\n"
"						  }\n"
"						else\n"
"						  {\n"
"							 ($extracted, $reduced_command) =\n"
"								Perl_cmiss::Text::Balanced::extract_variable($command);\n"
"							 if ($extracted)\n"
"								{\n"
"								  $command = $reduced_command;\n"
"								  if ($cmiss_debug)\n"
"									 {\n"
"										print \"variable: $extracted\\n\";\n"
"									 }\n"
"								  $token = $token . $extracted;\n"
"								}\n"
"							 else\n"
"								{\n"
"								  ($extracted, $reduced_command) =\n"
"									 Perl_cmiss::Text::Balanced::extract_quotelike($command);\n"
"								  if ($extracted)\n"
"									 {\n"
"										$command = $reduced_command;\n"
"										if ($cmiss_debug)\n"
"										  {\n"
"											 print \"quotelike: $extracted\\n\";\n"
"										  }\n"
"										$token = $token . $extracted;\n"
"									 }\n"
"								  else\n"
"									{\n"
"									  if ($command =~ s/^(\\w+)//)\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											{\n"
"											  print \"characters: \" . $1 . \"\\n\";\n"
"											}\n"
"										  $token = $token . $1;\n"
"										}\n"
"									  else\n"
"										{\n"
"										  if ($cmiss_debug)\n"
"											{\n"
"											  print \"punctuation: \" . substr($command, 0, 1) . \"\\n\";\n"
"											}\n"
"										  $token = $token . substr($command, 0, 1);\n"
"										  $command = substr($command, 1);\n"
"										}\n"
"									}\n"
"								}\n"
"						  }\n"
"					 }\n"
"				}\n"
"			}\n"
"		}\n"
"	 if ($token ne \"\")\n"
"		{\n"
"		  #Add a semicolon if not already there.\n"
"		  if ($simple_perl && (!$block_required) && (! ($token =~ m/;\\s*$/)))\n"
"			 {\n"
"				$token = $token . \";\";\n"
"			 }\n"
"		  push(@tokens, $token);\n"
"		}\n"
"						  \n"
"	$command = join (\"\", @tokens);\n"
"	if ($cmiss_debug)\n"
"	  {\n"
"		 print \"Perl_cmiss::execute_command parsed $command\\n\";\n"
"	  }\n"
"	if ($echo_commands && (! $print_command_after))\n"
"     {\n"
"		 push (@command_list, $command2);\n"
"	  }\n"
"   push (@command_list, $command);\n"
"   if ($echo_commands && $print_command_after)\n"
"     {\n"
"		 push (@command_list, $command2);\n"
"	  }\n"
"\n"
"#	 print \\\"$block_count $block_required\\\\n\\\";\n"
"\n"
"	 if ((!($block_count))&&(!($block_required)))\n"
"		{\n"
"		  $command = join (\"\\n\", @command_list);\n"
"		  #Must reset this before the eval as it may call this function\n"
"		  #recursively before returning from this function\n"
"		  @command_list = ();\n"
"		  call_command($command);\n"
"		  if ($@)\n"
"			 {\n"
"				#Trim the useless line number info if it has been added.\n"
"				$@ =~ s/ at \\(eval \\d+\\) line \\d+//;\n"
"				die(\"$@\\n\");\n"
"			 }\n"
"		  print \"\";\n"
"		}\n"
"  }\n"
"\n"
"### Local Variables:\n"
"### tab-width: 4\n"
"### End:\n"
