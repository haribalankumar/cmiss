"# EXTRACT VARIOUSLY DELIMITED TEXT SEQUENCES FROM STRINGS.\n"
"# FOR FULL DOCUMENTATION SEE Balanced.pod\n"
"\n"
"#use strict;\n"
"\n"
"#Hide this implementation so that it does not conflict with any real use of the Text::Balanced module.\n"
"package Perl_cmiss::Text::Balanced;\n"
"\n"
"#use Exporter;\n"
"#use SelfLoader;\n"
"#use vars qw { $VERSION @ISA %EXPORT_TAGS };\n"
"\n"
"#$VERSION = '1.66';\n"
"#@ISA		= qw ( Exporter );\n"
"		     \n"
"#%EXPORT_TAGS	= ( ALL => [ qw(\n"
"#				&delimited_pat\n"
"#\n"
"#				&extract_delimited\n"
"#				&extract_bracketed\n"
"#				&extract_quotelike\n"
"#				&extract_codeblock\n"
"#				&extract_variable\n"
"#				&extract_tagged\n"
"#				&extract_multiple\n"
"\n"
"#				&gen_extract_tagged\n"
"#			       ) ] );\n"
"\n"
"#Exporter::export_ok_tags('ALL');\n"
"\n"
"# PAY NO ATTENTION TO THE TRACE BEHIND THE CURTAIN\n"
"sub _trace($) {}\n"
"# sub _trace($) { print STDERR $_[0], \"\\n\"; }\n"
"\n"
"# HANDLE RETURN VALUES IN VARIOUS CONTEXTS\n"
"\n"
"sub _fail\n"
"{\n"
"	my $wantarray = shift;\n"
"	return @_ if $wantarray;\n"
"	return undef;\n"
"}\n"
"\n"
"sub _succeed\n"
"{\n"
"	$@ = undef;\n"
"	my $wantarray = shift;\n"
"	return @_[1..$#_]	if $wantarray;\n"
"	$_[0] = $_[2];		# MODIFY 1ST ARG IN NON-LIST CONTEXTS\n"
"	return $_[1]	 	if defined $wantarray;\n"
"	return undef;		# VOID CONTEXT\n"
"}\n"
"\n"
"# BUILD A PATTERN MATCHING A SIMPLE DELIMITED STRING\n"
"\n"
"sub delimited_pat($;$)  # ($delimiters;$escapes)\n"
"{\n"
"	my ($dels, $escs) = @_;\n"
"	return \"\" unless $dels =~ /\\S/;\n"
"	$escs = '\\\\' unless $escs;\n"
"	$escs .= substr($escs,-1) x (length($dels)-length($escs));\n"
"	my @pat = ();\n"
"	my $i;\n"
"	for ($i=0; $i<length $dels; $i++)\n"
"	{\n"
"		my $del = quotemeta substr($dels,$i,1);\n"
"		my $esc = quotemeta substr($escs,$i,1);\n"
"		if ($del eq $esc)\n"
"		{\n"
"			push @pat, \"$del(?:[^$del]*(?:(?:$del$del)[^$del]*)*)$del\";\n"
"		}\n"
"		else\n"
"		{\n"
"			push @pat, \"$del(?:[^$esc$del]*(?:$esc.[^$esc$del]*)*)$del\";\n"
"		}\n"
"	}\n"
"	my $pat = join '|', @pat;\n"
"	return \"(?:$pat)\";\n"
"}\n"
"\n"
"\n"
"# THE EXTRACTION FUNCTIONS\n"
"\n"
"sub extract_delimited (;$$$$)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0] : $_;\n"
"	my @fail = (wantarray,undef,$text);\n"
"	my $del  = defined $_[1] ? $_[1] : qq{\\'\\\"\\`};\n"
"	my $pre  = defined $_[2] ? $_[2] : '\\s*';\n"
"	my $esc  = defined $_[3] ? $_[3] : qq{\\\\};\n"
"	eval \"'' =~ /$pre/; 1\" or return _fail @fail;\n"
"	my $pat = delimited_pat($del, $esc);\n"
"	return _succeed (wantarray,(defined $_[0] ? $_[0] : $_),$2,$3,$1)\n"
"		if $text =~ /\\A($pre)($pat)(.*)/s;\n"
"	$@ = \"Could not extract \\\"$del\\\"-delimited substring\";\n"
"	return _fail @fail;\n"
"}\n"
"\n"
"sub extract_bracketed (;$$$)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0] : defined $_ ? $_ : '';\n"
"	my $orig = $text;\n"
"	my $ldel = defined $_[1] ? $_[1] : '{([<';\n"
"	my $pre  = defined $_[2] ? $_[2] : '\\s*';\n"
"	my @fail = (wantarray,undef,$text);\n"
"\n"
"	unless ($text =~ s/\\A($pre)//s)\n"
"		{ $@ = \"Did not find prefix: /$pre/\"; return _fail @fail; }\n"
"\n"
"	$pre = $1;\n"
"	my $qdel = \"\";\n"
"	my $quotelike;\n"
"	$ldel =~ s/'//g and $qdel .= q{'};\n"
"	$ldel =~ s/\"//g and $qdel .= q{\"};\n"
"	$ldel =~ s/`//g and $qdel .= q{`};\n"
"	$ldel =~ s/q//g and $quotelike = 1;\n"
"	$ldel =~ tr/[](){}<>\\0-\\377/[[(({{<</ds;\n"
"	my $rdel = $ldel;\n"
"\n"
"	unless ($rdel =~ tr/[({</])}>/)\n"
"	    { $@ = \"Did not find a suitable bracket: \\\"$ldel\\\"\"; return _fail @fail; }\n"
"\n"
"	$ldel = join('|', map { quotemeta $_ } split('', $ldel));\n"
"	$rdel = join('|', map { quotemeta $_ } split('', $rdel));\n"
"\n"
"	unless ($text =~ m/\\A($ldel)/)\n"
"	    { $@ = \"Did not find opening bracket after prefix: \\\"$pre\\\"\";\n"
"	      return _fail @fail; }\n"
"\n"
"	my @nesting = ();\n"
"	while (length $text)\n"
"	{\n"
"		next if $text =~ s/\\A\\\\.//s;\n"
"\n"
"		if ($text =~ s/\\A($ldel)//)\n"
"		{\n"
"			push @nesting, $1;\n"
"		}\n"
"		elsif ($text =~ s/\\A($rdel)//)\n"
"		{\n"
"			my ($found, $brackettype) = ($1, $1);\n"
"			if ($#nesting < 0)\n"
"				{ $@ = \"Unmatched closing bracket: \\\"$found\\\"\";\n"
"			          return _fail @fail; }\n"
"			my $expected = pop(@nesting);\n"
"			$expected =~ tr/({[</)}]>/;\n"
"			if ($expected ne $brackettype)\n"
"				{ $@ = \"Mismatched closing bracket: expected \\\"$expected\\\" but found \\\"$found\" . substr($text,0,10) . \"\\\"\";\n"
"			          return _fail @fail; }\n"
"			last if $#nesting < 0;\n"
"		}\n"
"		elsif ($qdel && $text =~ m/\\A([$qdel])/)\n"
"		{\n"
"			$text =~ s/\\A([$1])(\\\\\\1|(?!\\1).)*\\1//s and next;\n"
"			$@ = \"Unmatched embedded quote ($1)\";\n"
"		        return _fail @fail;\n"
"		}\n"
"		elsif ($quotelike && extract_quotelike($text))\n"
"		{\n"
"			next;\n"
"		}\n"
"\n"
"		else { $text =~ s/[a-zA-Z0-9]+|.//s }\n"
"	}\n"
"	if ($#nesting>=0)\n"
"		{ $@ = \"Unmatched opening bracket(s): \"\n"
"		     . join(\"..\",@nesting).\"..\";\n"
"		  return _fail @fail; }\n"
"	my $prelen = length $pre;\n"
"	return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"			substr($orig,$prelen,length($orig)-length($text)-$prelen),\n"
"			$text,\n"
"		        $pre;\n"
"}\n"
"\n"
"sub revbracket($)\n"
"{\n"
"	my $brack = reverse $_[0];\n"
"	$brack =~ tr/[({</])}>/;\n"
"	return $brack;\n"
"}\n"
"\n"
"my $XMLNAME = q{[a-zA-Z_:][a-zA-Z_:.-]*};\n"
"\n"
"sub extract_tagged (;$$$$$)\n"
"	   # ($text, $opentag, $closetag, $pre, \\%options)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0] : defined $_ ? $_ : '';\n"
"	my $orig = $text;\n"
"	my $ldel = $_[1];\n"
"	my $rdel = $_[2];\n"
"	my $pre  = defined $_[3] ? $_[3] : '\\s*';\n"
"	my %options = defined $_[4] ? %{$_[4]} : ();\n"
"	my $omode = defined $options{fail} ? $options{fail} : '';\n"
"	my $bad     = ref($options{reject}) eq 'ARRAY' ? join('|', @{$options{reject}})\n"
"		    : defined($options{reject})	       ? $options{reject}\n"
"		    :					 ''\n"
"		    ;\n"
"	my $ignore  = ref($options{ignore}) eq 'ARRAY' ? join('|', @{$options{ignore}})\n"
"		    : defined($options{ignore})	       ? $options{ignore}\n"
"		    :					 ''\n"
"		    ;\n"
"	my @fail = (wantarray,undef,$text);\n"
"	$@ = undef;\n"
"\n"
"	unless ($text =~ s/\\A($pre)//s)\n"
"		{ $@ = \"Did not find prefix: /$pre/\"; return _fail @fail; }\n"
"\n"
"	$pre = $1;\n"
"	my $prelen = length $pre;\n"
"\n"
"	if (!defined $ldel) { $ldel = '<\\w+(?:' . delimited_pat(q{'\"}) . '|[^>])*>'; }\n"
"\n"
"	unless ($text =~ s/\\A($ldel)//s)\n"
"		{ $@ = \"Did not find opening tag: /$ldel/\"; return _fail @fail; }\n"
"\n"
"	my $ldellen = length($1);\n"
"	my $rdellen = 0;\n"
"\n"
"	if (!defined $rdel)\n"
"	{\n"
"		$rdel = $1;\n"
"		unless ($rdel =~ s/\\A([[(<{]+)($XMLNAME).*/ \"$1\\/$2\". revbracket($1) /es)\n"
"		{\n"
"			$@ = \"Unable to construct closing tag to match: /$ldel/\";\n"
"			return _fail @fail;\n"
"		}\n"
"	}\n"
"\n"
"	my ($nexttok, $fail);\n"
"	while (length $text)\n"
"	{\n"
"		_trace(\"at: $text\");\n"
"		next if $text =~ s/\\A\\\\.//s;\n"
"\n"
"		if ($text =~ s/\\A($rdel)//s )\n"
"		{\n"
"			$rdellen = length $1;\n"
"			goto matched;\n"
"		}\n"
"		elsif ($ignore && $text =~ s/\\A(?:$ignore)//s)\n"
"		{\n"
"			next;\n"
"		}\n"
"		elsif ($bad && $text =~ m/\\A($bad)/s)\n"
"		{\n"
"			goto short if ($omode eq 'PARA' || $omode eq 'MAX');\n"
"			$@ = \"Found invalid nested tag: $1\";\n"
"			return _fail @fail;\n"
"		}\n"
"		elsif ($text =~ m/\\A($ldel)/s)\n"
"		{\n"
"			if (!defined extract_tagged($text, @_[1..$#_]))\n"
"			{\n"
"				goto short if ($omode eq 'PARA' || $omode eq 'MAX');\n"
"				$@ = \"Found unbalanced nested tag: $1\";\n"
"				return _fail @fail;\n"
"			}\n"
"		}\n"
"		else { $text =~ s/.//s }\n"
"	}\n"
"\n"
"short:\n"
"	if ($omode eq 'PARA')\n"
"	{\n"
"		my $textlen = length($text);\n"
"		my $init = ($textlen) ? substr($orig,0,-$textlen)\n"
"				      : substr($orig,0);\n"
"		$init =~ s/\\A(.*?\\n)([ \\t]*\\n.*)\\Z/$1/s;\n"
"		$text = ($2||'').$text;\n"
"	}\n"
"	elsif ($omode ne 'MAX')\n"
"	{\n"
"		goto failed;\n"
"	}\n"
"\n"
"matched:\n"
"	my $matched = substr($orig,$prelen,length($orig)-length($text)-$prelen);\n"
"	_trace(\"extracted: $matched\");\n"
"	return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"			$matched,\n"
"			$text,\n"
"			$pre,\n"
"			substr($matched,0,$ldellen)||'',\n"
"			($rdellen)\n"
"				? substr($matched,$ldellen,-$rdellen)\n"
"				: substr($matched,$ldellen),\n"
"			($rdellen)\n"
"				? substr($matched,-$rdellen)\n"
"				: '';\n"
"\n"
"failed:\n"
"	$@ = \"Did not find closing tag\" unless $@;\n"
"	return _fail @fail;\n"
"}\n"
"\n"
"sub extract_variable (;$$)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0] : defined $_ ? $_ : '';\n"
"	my $orig = $text;\n"
"	my $pre  = defined $_[1] ? $_[1] : '\\s*';\n"
"	my @fail = (wantarray,undef,$text);\n"
"	unless ($text =~ s/\\A($pre)//s)\n"
"		{ $@ = \"Did not find prefix: /$pre/\"; return _fail @fail; }\n"
"	$pre = $1;\n"
"	unless ($text =~ s/\\A(\\S#|[\\$\\@\\%])+//s)\n"
"		{ $@ = \"Did not find leading dereferencer\";\n"
"		  return _fail @fail; }\n"
"\n"
"	unless ($text =~ s/\\A\\s*(?:::)?(?:[_a-z]\\w*::)*[_a-z]\\w*//i  or extract_codeblock($text,'{}'))\n"
"		{ $@ = \"Bad identifier after dereferencer\";\n"
"		  return _fail @fail; }\n"
"#SAB I took out the round bracket pair as it was causing me trouble.\n"
"	1 while (  extract_codeblock($text,'{}[]','\\s*(?:->(?:\\s*\\w+\\s*)?)?\\s*')\n"
"	        || extract_variable($text,'\\s*->\\s*')\n"
"	        );\n"
"\n"
"	return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"			substr($orig,0,length($orig)-length($text)),\n"
"			$text,\n"
"			$pre;\n"
"}\n"
"\n"
"sub extract_codeblock (;$$$$)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0] : defined $_ ? $_ : '';\n"
"	my $orig = $text;\n"
"	my $del  = defined $_[1] ? $_[1] : '{';\n"
"	my $pre  = defined $_[2] ? $_[2] : '\\s*';\n"
"	my $rd   = $_[3];\n"
"	my ($ldel, $rdel) = ($del, $del);\n"
"	$ldel =~ tr/[]()<>{}\\0-\\377/[[((<<{{/ds;\n"
"	$rdel =~ tr/[]()<>{}\\0-\\377/]]))>>}}/ds;\n"
"	$ldel = '('.join('|',map { quotemeta $_ } split('',$ldel)).')';\n"
"	$rdel = '('.join('|',map { quotemeta $_ } split('',$rdel)).')';\n"
"	_trace(\"Trying /$ldel/../$rdel/\");\n"
"	my @fail = (wantarray,undef,$text);\n"
"	unless ($text =~ s/\\A($pre)//s)\n"
"		{ $@ = \"Did not find prefix: /$pre/\"; return _fail @fail; }\n"
"	$pre = $1;\n"
"	unless ($text =~ s/\\A$ldel//s)\n"
"		{ $@ = \"Did not find opening bracket after prefix: \\\"$pre\\\"\";\n"
"		  return _fail @fail; }\n"
"	my $closing = $1;\n"
"	   $closing =~ tr/([<{/)]>}/;\n"
"	my $matched;\n"
"	my $patvalid = 1;\n"
"	while (length $text)\n"
"	{\n"
"		$matched = '';\n"
"		if ($rd && $text =~ s#\\A(\\Q(?)\\E|\\Q(s?)\\E|\\Q(s)\\E)##)\n"
"		{\n"
"			$patvalid = 0;\n"
"			next;\n"
"		}\n"
"\n"
"		if ($text =~ s/\\A\\s*#.*//)\n"
"		{\n"
"			next;\n"
"		}\n"
"\n"
"		if ($text =~ s/\\A\\s*$rdel//)\n"
"		{\n"
"			$matched = ($1 eq $closing);\n"
"			unless ($matched)\n"
"			{\n"
"				$@ = \"Mismatched closing bracket: expected \\\"\"\n"
"				   . \"$closing\\\" but found \\\"$1\"\n"
"				   . substr($text,0,10) . \"\\\"\";\n"
"			}\n"
"			last;\n"
"		}\n"
"\n"
"		if ($text =~ s!\\A\\s*(=~|\\!~|split|grep|map|return|;|[|]{1,2}|[&]{1.2})!!)\n"
"		{\n"
"			$patvalid = 1;\n"
"			next;\n"
"		}\n"
"\n"
"		if (extract_variable($text))\n"
"		{\n"
"			$patvalid = 0;\n"
"			next;\n"
"		}\n"
"\n"
"		if ($text =~ m!\\A\\s*(m|s|qq|qx|qw|q|tr|y)\\b\\s*\\S!\n"
"		 or $text =~ m!\\A\\s*[\\\"\\'\\`]!\n"
"		 or $patvalid and $text =~ m!\\A\\s*[/?]!)\n"
"		{\n"
"			_trace(\"Trying quotelike at [\".substr($text,0,30).\"]\");\n"
"			($matched,$text) = extract_quotelike($text);\n"
"			if ($matched) { $patvalid = 0; next; }\n"
"			_trace(\"...quotelike failed\");\n"
"		}\n"
"\n"
"		if ($text =~ m/\\A\\s*$ldel/)\n"
"		{\n"
"			_trace(\"Trying codeblock at [\".substr($text,0,30).\"]\");\n"
"			($matched,$text) = extract_codeblock($text,$del,undef,$rd);\n"
"			if ($matched) { $patvalid = 1; next; }\n"
"			_trace(\"...codeblock failed\");\n"
"			$@ = \"Nested codeblock failed to balance from \\\"\"\n"
"				.  substr($text,0,10) . \"...\\\"\";\n"
"			last;\n"
"		}\n"
"\n"
"		$patvalid = 0;\n"
"		$text =~ s/\\s*(\\w+|[-=>]>|.)//s;\n"
"		_trace(\"Skipping: [$1]\");\n"
"	}\n"
"\n"
"	unless ($matched)\n"
"	{\n"
"		$@ = 'No match found for opening bracket' unless $@;\n"
"		return _fail @fail;\n"
"	}\n"
"	return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"			substr($orig,0,length($orig)-length($text)),\n"
"			$text,\n"
"			$pre;\n"
"}\n"
"\n"
"my %mods   = (\n"
"		'none'	=> '[gimsox]*',\n"
"		'm'	=> '[gimsox]*',\n"
"		's'	=> '[egimsox]*',\n"
"		'tr'	=> '[cds]*',\n"
"		'y'	=> '[cds]*',\n"
"		'qq'	=> '',\n"
"		'qx'	=> '',\n"
"		'qw'	=> '',\n"
"		'q'	=> '',\n"
"	     );\n"
"\n"
"sub extract_quotelike (;$$)\n"
"{\n"
"	my $text = $_[0] ? $_[0] : defined $_ ? $_ : '';\n"
"	my $wantarray = wantarray;\n"
"	my @fail = (wantarray,undef,$text);\n"
"	my $pre  = defined $_[1] ? $_[1] : '\\s*';\n"
"\n"
"	my $ldel1  = '';\n"
"	my $block1 = '';\n"
"	my $rdel1  = '';\n"
"	my $ldel2  = '';\n"
"	my $block2 = '';\n"
"	my $rdel2  = '';\n"
"	my $mods   = '';\n"
"\n"
"\n"
"	unless ($text =~ s/\\A($pre)//s)\n"
"		{ $@ = \"Did not find prefix: /$pre/\"; return _fail @fail; }\n"
"	$pre = $1;\n"
"	my $orig = $text;\n"
"\n"
"	if ($text =~ m!\\A([/?\\\"\\'\\`])!)\n"
"	{\n"
"		$ldel1= $rdel1= $1;\n"
"		my $matched;\n"
"		($matched,$text) = extract_delimited($text, $ldel1);\n"
"	        return _fail @fail unless $matched;\n"
"		my $mods = '';\n"
"		if ($ldel1 =~ m![/]()!) \n"
"			{ $text =~ s/\\A($mods{none})// and $mods = $1; }\n"
"		return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"		       ($matched.$mods,$text,$pre,\n"
"			'',					# OPERATOR\n"
"			$ldel1,					# BLOCK 1 LEFT DELIM\n"
"			substr($matched,1,length($matched)-2),	# BLOCK 1\n"
"			$rdel1,					# BLOCK 1 RIGHT DELIM\n"
"			'',					# BLOCK 2 LEFT DELIM\n"
"			'',					# BLOCK 2 \n"
"			'',					# BLOCK 2 RIGHT DELIM\n"
"			$mods					# MODIFIERS\n"
"			);\n"
"	}\n"
"\n"
"	unless ($text =~ s!\\A(m|s|qq|qx|qw|q|tr|y)\\b(?=\\s*\\S)!!s)\n"
"	{\n"
"		$@ = \"No quotelike function found after prefix: \\\"$pre\\\"\";\n"
"		return _fail @fail\n"
"	}\n"
"	my $quotelike = $1;\n"
"\n"
"	unless ($text =~ /\\A\\s*(\\S)/)\n"
"	{\n"
"		$@ = \"No block delimiter found after quotelike $quotelike\";\n"
"		return _fail @fail;\n"
"	}\n"
"	$ldel1= $rdel1= $1;\n"
"	if ($ldel1 =~ /[[(<{]/)\n"
"	{\n"
"		$rdel1 =~ tr/[({</])}>/;\n"
"		($block1,$text) = extract_bracketed($text,$ldel1);\n"
"		# COULD BE ($block1,$text) = extract_codeblock($text,$ldel1);\n"
"	}\n"
"	else\n"
"	{\n"
"		($block1,$text) = extract_delimited($text,$ldel1);\n"
"	}\n"
"	return _fail @fail if !$block1;\n"
"	$block1 =~ s/.(.*)./$1/s;\n"
"\n"
"	if ($quotelike =~ /s|tr|y/)\n"
"	{\n"
"		if ($ldel1 =~ /[[(<{]/)\n"
"		{\n"
"			unless ($text =~ /\\A\\s*(\\S)/)\n"
"			{\n"
"				$@ = \"Missing second block for quotelike $quotelike\";\n"
"				return _fail @fail;\n"
"			}\n"
"			$ldel2= $rdel2= $1;\n"
"			$rdel2 =~ tr/[({</])}>/;\n"
"		}\n"
"		else\n"
"		{\n"
"			$ldel2= $rdel2= $ldel1;\n"
"			$text = $ldel2.$text;\n"
"		}\n"
"\n"
"		if ($ldel2 =~ /[[(<{]/)\n"
"		{\n"
"			($block2,$text) = extract_bracketed($text,$ldel2);\n"
"			# COULD BE ($block2,$text) = extract_codeblock($text,$ldel2);\n"
"		}\n"
"		else\n"
"		{\n"
"			($block2,$text) = extract_delimited($text,$ldel2);\n"
"		}\n"
"		return _fail @fail if !$block2;\n"
"	}\n"
"	$block2 =~ s/.(.*)./$1/s;\n"
"\n"
"	$text =~ s/\\A($mods{$quotelike})//;\n"
"\n"
"	return _succeed wantarray,\n"
"			(defined $_[0] ? $_[0] : $_),\n"
"	       		substr($orig,0,length($orig)-length($text)),\n"
"			$text,\n"
"			$pre,\n"
"			$quotelike,	# OPERATOR\n"
"			$ldel1,		\n"
"			$block1,\n"
"			$rdel1,\n"
"			$ldel2,		\n"
"			$block2,\n"
"			$rdel2,\n"
"			$1?$1:''	# MODIFIERS\n"
"			;\n"
"}\n"
"\n"
"my $def_func = \n"
"[\n"
"	sub { extract_variable($_[0], '') },\n"
"	sub { extract_quotelike($_[0],'') },\n"
"	sub { extract_codeblock($_[0],'{}','') },\n"
"];\n"
"\n"
"sub extract_multiple (;$$$$)	# ($text, $functions_ref, $max_fields, $ignoreunknown)\n"
"{\n"
"	my $text = defined $_[0] ? $_[0]    : $_;\n"
"	my @func = defined $_[1] ? @{$_[1]} : @$def_func;\n"
"	my $max  = defined $_[2] && $_[2]>0 ? $_[2] : 1_000_000_000;\n"
"	my $igunk = $_[3];\n"
"\n"
"	$max = 2 unless wantarray;\n"
"\n"
"	my @fields = ();\n"
"	my $unknown = \"\";\n"
"	my $field = \"\";\n"
"	my $remainder = \"\";\n"
"	my $func;\n"
"\n"
"	FIELD: while ($text && @fields<$max-1)\n"
"	{\n"
"		foreach $func ( @func )\n"
"		{\n"
"			($field,$remainder) = &$func($text);\n"
"			if ($field)\n"
"			{\n"
"				if ($unknown)\n"
"				{\n"
"					push @fields, $unknown unless $igunk;\n"
"					$unknown = \"\";\n"
"				}\n"
"				push @fields, $field;\n"
"				$field = \"\";\n"
"				$text = $remainder;\n"
"				next FIELD;\n"
"			}\n"
"		}\n"
"		$unknown .= substr($text,0,1);\n"
"		substr($text,0,1) = \"\";\n"
"	}\n"
"	push @fields, $unknown if $unknown && ! $igunk;\n"
"	push @fields, $text    if $text;\n"
"\n"
"	splice @fields, $max-1, @fields-$max+1,\n"
"		join('',@fields[$max-1..$#fields])\n"
"			if @fields>$max;\n"
"\n"
"	return @fields if wantarray;\n"
"	eval { $_[0] = $fields[1] };\n"
"	return $fields[0];\n"
"}\n"
"\n"
